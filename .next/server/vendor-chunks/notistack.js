"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/notistack";
exports.ids = ["vendor-chunks/notistack"];
exports.modules = {

/***/ "(ssr)/./node_modules/notistack/node_modules/clsx/dist/clsx.m.js":
/*!*****************************************************************!*\
  !*** ./node_modules/notistack/node_modules/clsx/dist/clsx.m.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm90aXN0YWNrL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsY0FBYyxhQUFhLCtDQUErQyx1REFBdUQsV0FBVywwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQixxQkFBcUIsbUJBQW1CLGtEQUFrRCxTQUFTLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb2hhbWVkYWhtZWQvRG9jdW1lbnRzL0dpdEh1Yi9TdXBlci1zaGVldC1hZG1pbi1GRS9ub2RlX21vZHVsZXMvbm90aXN0YWNrL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/notistack/node_modules/clsx/dist/clsx.m.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/notistack/notistack.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/notistack/notistack.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaterialDesignContent: () => (/* binding */ MaterialDesignContent$1),\n/* harmony export */   SnackbarContent: () => (/* binding */ SnackbarContent),\n/* harmony export */   SnackbarProvider: () => (/* binding */ SnackbarProvider),\n/* harmony export */   Transition: () => (/* binding */ Transition),\n/* harmony export */   closeSnackbar: () => (/* binding */ closeSnackbar),\n/* harmony export */   enqueueSnackbar: () => (/* binding */ enqueueSnackbar),\n/* harmony export */   useSnackbar: () => (/* binding */ useSnackbar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/notistack/node_modules/clsx/dist/clsx.m.js\");\n/* harmony import */ var goober__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! goober */ \"(ssr)/./node_modules/goober/dist/goober.modern.js\");\n\n\n\n\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar noOp = function noOp() {\n  return '';\n};\n\nvar SnackbarContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  enqueueSnackbar: noOp,\n  closeSnackbar: noOp\n});\n\nvar breakpoints = {\n  downXs: '@media (max-width:599.95px)',\n  upSm: '@media (min-width:600px)'\n};\n\nvar capitalise = function capitalise(text) {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n};\n\nvar originKeyExtractor = function originKeyExtractor(anchor) {\n  return \"\" + capitalise(anchor.vertical) + capitalise(anchor.horizontal);\n};\nvar isDefined = function isDefined(value) {\n  return !!value || value === 0;\n};\n\nvar UNMOUNTED = 'unmounted';\nvar EXITED = 'exited';\nvar ENTERING = 'entering';\nvar ENTERED = 'entered';\nvar EXITING = 'exiting';\n\nvar Transition = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Transition, _React$Component);\n\n  function Transition(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    var appear = props.appear;\n    var initialStatus;\n    _this.appearStatus = null;\n\n    if (props[\"in\"]) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else if (props.unmountOnExit || props.mountOnEnter) {\n      initialStatus = UNMOUNTED;\n    } else {\n      initialStatus = EXITED;\n    }\n\n    _this.state = {\n      status: initialStatus\n    };\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref[\"in\"];\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return {\n        status: EXITED\n      };\n    }\n\n    return null;\n  };\n\n  var _proto = Transition.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n      if (this.props[\"in\"]) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else if (status === ENTERING || status === ENTERED) {\n        nextStatus = EXITING;\n      }\n    }\n\n    this.updateStatus(false, nextStatus);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  _proto.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n    var enter = timeout;\n    var exit = timeout;\n\n    if (timeout != null && typeof timeout !== 'number' && typeof timeout !== 'string') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n    }\n\n    return {\n      exit: exit,\n      enter: enter\n    };\n  };\n\n  _proto.updateStatus = function updateStatus(mounting, nextStatus) {\n    if (mounting === void 0) {\n      mounting = false;\n    }\n\n    if (nextStatus !== null) {\n      this.cancelNextCallback();\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(mounting);\n      } else {\n        this.performExit();\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({\n        status: UNMOUNTED\n      });\n    }\n  };\n\n  _proto.performEnter = function performEnter(mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n    var isAppearing = mounting;\n    var timeouts = this.getTimeouts();\n\n    if (!mounting && !enter) {\n      this.safeSetState({\n        status: ENTERED\n      }, function () {\n        if (_this2.props.onEntered) {\n          _this2.props.onEntered(_this2.node, isAppearing);\n        }\n      });\n      return;\n    }\n\n    if (this.props.onEnter) {\n      this.props.onEnter(this.node, isAppearing);\n    }\n\n    this.safeSetState({\n      status: ENTERING\n    }, function () {\n      if (_this2.props.onEntering) {\n        _this2.props.onEntering(_this2.node, isAppearing);\n      }\n\n      _this2.onTransitionEnd(timeouts.enter, function () {\n        _this2.safeSetState({\n          status: ENTERED\n        }, function () {\n          if (_this2.props.onEntered) {\n            _this2.props.onEntered(_this2.node, isAppearing);\n          }\n        });\n      });\n    });\n  };\n\n  _proto.performExit = function performExit() {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n    var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED\n\n    if (!exit) {\n      this.safeSetState({\n        status: EXITED\n      }, function () {\n        if (_this3.props.onExited) {\n          _this3.props.onExited(_this3.node);\n        }\n      });\n      return;\n    }\n\n    if (this.props.onExit) {\n      this.props.onExit(this.node);\n    }\n\n    this.safeSetState({\n      status: EXITING\n    }, function () {\n      if (_this3.props.onExiting) {\n        _this3.props.onExiting(_this3.node);\n      }\n\n      _this3.onTransitionEnd(timeouts.exit, function () {\n        _this3.safeSetState({\n          status: EXITED\n        }, function () {\n          if (_this3.props.onExited) {\n            _this3.props.onExited(_this3.node);\n          }\n        });\n      });\n    });\n  };\n\n  _proto.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null && this.nextCallback.cancel) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  _proto.safeSetState = function safeSetState(nextState, callback) {\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  _proto.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function () {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n        callback();\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {\n    this.setNextCallback(handler);\n    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;\n\n    if (!this.node || doesNotHaveTimeoutOrListener) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n\n    if (this.props.addEndListener) {\n      this.props.addEndListener(this.node, this.nextCallback);\n    }\n\n    if (timeout != null) {\n      setTimeout(this.nextCallback, timeout);\n    }\n  };\n\n  _proto.render = function render() {\n    var status = this.state.status;\n\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        childProps = _objectWithoutPropertiesLoose(_this$props, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n\n    return children(status, childProps);\n  };\n\n  _createClass(Transition, [{\n    key: \"node\",\n    get: function get() {\n      var _this$props$nodeRef;\n\n      var node = (_this$props$nodeRef = this.props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current;\n\n      if (!node) {\n        throw new Error('notistack - Custom snackbar is not refForwarding');\n      }\n\n      return node;\n    }\n  }]);\n\n  return Transition;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\n\nfunction noop() {//\n}\n\nTransition.defaultProps = {\n  \"in\": false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n */\n/**\r\n * passes {value} to {ref}\r\n *\r\n * Useful if you want to expose the ref of an inner component to the public API\r\n * while still using it inside the component.\r\n * @param ref A ref callback or ref object. If anything falsy, this is a no-op.\r\n */\n\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nfunction useForkRef(refA, refB) {\n  /**\r\n   * This will create a new function if the ref props change and are defined.\r\n   * This means react will call the old forkRef with `null` and the new forkRef\r\n   * with the ref. Cleanup naturally emerges from this behavior.\r\n   */\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n\nfunction getTransitionProps(props) {\n  var timeout = props.timeout,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {} : _props$style,\n      mode = props.mode;\n  return {\n    duration: typeof timeout === 'object' ? timeout[mode] || 0 : timeout,\n    easing: style.transitionTimingFunction,\n    delay: style.transitionDelay\n  };\n}\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n */\nvar defaultEasing = {\n  // This is the most common easing curve.\n  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',\n  // Objects enter the screen at full velocity from off-screen and\n  // slowly decelerate to a resting point.\n  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',\n  // Objects leave the screen at full velocity. They do not decelerate when off-screen.\n  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',\n  // The sharp curve is used by objects that may return to the screen at any time.\n  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'\n};\n/**\r\n * CSS hack to force a repaint\r\n */\n\nvar reflow = function reflow(node) {\n  // We have to do something with node.scrollTop.\n  // Otherwise it's removed from the compiled code by optimisers\n  // eslint-disable-next-line no-self-assign\n  node.scrollTop = node.scrollTop;\n};\n\nvar formatMs = function formatMs(milliseconds) {\n  return Math.round(milliseconds) + \"ms\";\n};\n\nfunction createTransition(props, options) {\n  if (props === void 0) {\n    props = ['all'];\n  }\n\n  var _ref = options || {},\n      _ref$duration = _ref.duration,\n      duration = _ref$duration === void 0 ? 300 : _ref$duration,\n      _ref$easing = _ref.easing,\n      easing = _ref$easing === void 0 ? defaultEasing.easeInOut : _ref$easing,\n      _ref$delay = _ref.delay,\n      delay = _ref$delay === void 0 ? 0 : _ref$delay;\n\n  var properties = Array.isArray(props) ? props : [props];\n  return properties.map(function (animatedProp) {\n    var formattedDuration = typeof duration === 'string' ? duration : formatMs(duration);\n    var formattedDelay = typeof delay === 'string' ? delay : formatMs(delay);\n    return animatedProp + \" \" + formattedDuration + \" \" + easing + \" \" + formattedDelay;\n  }).join(',');\n}\n\nfunction ownerDocument(node) {\n  return node && node.ownerDocument || document;\n}\n\nfunction ownerWindow(node) {\n  var doc = ownerDocument(node);\n  return doc.defaultView || window;\n}\n/**\r\n * Corresponds to 10 frames at 60 Hz.\r\n * A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.\r\n */\n\n\nfunction debounce(func, wait) {\n  if (wait === void 0) {\n    wait = 166;\n  }\n\n  var timeout;\n\n  function debounced() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var later = function later() {\n      // @ts-ignore\n      func.apply(_this, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  }\n\n  debounced.clear = function () {\n    clearTimeout(timeout);\n  };\n\n  return debounced;\n}\n/**\r\n * Translate the node so it can't be seen on the screen.\r\n * Later, we're going to translate the node back to its original location with `none`.\r\n */\n\n\nfunction getTranslateValue(direction, node) {\n  var rect = node.getBoundingClientRect();\n  var containerWindow = ownerWindow(node);\n  var transform;\n\n  if (node.fakeTransform) {\n    transform = node.fakeTransform;\n  } else {\n    var computedStyle = containerWindow.getComputedStyle(node);\n    transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');\n  }\n\n  var offsetX = 0;\n  var offsetY = 0;\n\n  if (transform && transform !== 'none' && typeof transform === 'string') {\n    var transformValues = transform.split('(')[1].split(')')[0].split(',');\n    offsetX = parseInt(transformValues[4], 10);\n    offsetY = parseInt(transformValues[5], 10);\n  }\n\n  switch (direction) {\n    case 'left':\n      return \"translateX(\" + (containerWindow.innerWidth + offsetX - rect.left) + \"px)\";\n\n    case 'right':\n      return \"translateX(-\" + (rect.left + rect.width - offsetX) + \"px)\";\n\n    case 'up':\n      return \"translateY(\" + (containerWindow.innerHeight + offsetY - rect.top) + \"px)\";\n\n    default:\n      // down\n      return \"translateY(-\" + (rect.top + rect.height - offsetY) + \"px)\";\n  }\n}\n\nfunction setTranslateValue(direction, node) {\n  if (!node) return;\n  var transform = getTranslateValue(direction, node);\n\n  if (transform) {\n    node.style.webkitTransform = transform;\n    node.style.transform = transform;\n  }\n}\n\nvar Slide = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var children = props.children,\n      _props$direction = props.direction,\n      direction = _props$direction === void 0 ? 'down' : _props$direction,\n      inProp = props[\"in\"],\n      style = props.style,\n      _props$timeout = props.timeout,\n      timeout = _props$timeout === void 0 ? 0 : _props$timeout,\n      onEnter = props.onEnter,\n      onEntered = props.onEntered,\n      onExit = props.onExit,\n      onExited = props.onExited,\n      other = _objectWithoutPropertiesLoose(props, [\"children\", \"direction\", \"in\", \"style\", \"timeout\", \"onEnter\", \"onEntered\", \"onExit\", \"onExited\"]);\n\n  var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var handleRefIntermediary = useForkRef(children.ref, nodeRef);\n  var handleRef = useForkRef(handleRefIntermediary, ref);\n\n  var handleEnter = function handleEnter(node, isAppearing) {\n    setTranslateValue(direction, node);\n    reflow(node);\n\n    if (onEnter) {\n      onEnter(node, isAppearing);\n    }\n  };\n\n  var handleEntering = function handleEntering(node) {\n    var easing = (style === null || style === void 0 ? void 0 : style.transitionTimingFunction) || defaultEasing.easeOut;\n    var transitionProps = getTransitionProps({\n      timeout: timeout,\n      mode: 'enter',\n      style: _extends({}, style, {\n        transitionTimingFunction: easing\n      })\n    });\n    node.style.webkitTransition = createTransition('-webkit-transform', transitionProps);\n    node.style.transition = createTransition('transform', transitionProps);\n    node.style.webkitTransform = 'none';\n    node.style.transform = 'none';\n  };\n\n  var handleExit = function handleExit(node) {\n    var easing = (style === null || style === void 0 ? void 0 : style.transitionTimingFunction) || defaultEasing.sharp;\n    var transitionProps = getTransitionProps({\n      timeout: timeout,\n      mode: 'exit',\n      style: _extends({}, style, {\n        transitionTimingFunction: easing\n      })\n    });\n    node.style.webkitTransition = createTransition('-webkit-transform', transitionProps);\n    node.style.transition = createTransition('transform', transitionProps);\n    setTranslateValue(direction, node);\n\n    if (onExit) {\n      onExit(node);\n    }\n  };\n\n  var handleExited = function handleExited(node) {\n    // No need for transitions when the component is hidden\n    node.style.webkitTransition = '';\n    node.style.transition = '';\n\n    if (onExited) {\n      onExited(node);\n    }\n  };\n\n  var updatePosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (nodeRef.current) {\n      setTranslateValue(direction, nodeRef.current);\n    }\n  }, [direction]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    // Skip configuration where the position is screen size invariant.\n    if (inProp || direction === 'down' || direction === 'right') {\n      return undefined;\n    }\n\n    var handleResize = debounce(function () {\n      if (nodeRef.current) {\n        setTranslateValue(direction, nodeRef.current);\n      }\n    });\n    var containerWindow = ownerWindow(nodeRef.current);\n    containerWindow.addEventListener('resize', handleResize);\n    return function () {\n      handleResize.clear();\n      containerWindow.removeEventListener('resize', handleResize);\n    };\n  }, [direction, inProp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!inProp) {\n      // We need to update the position of the drawer when the direction change and\n      // when it's hidden.\n      updatePosition();\n    }\n  }, [inProp, updatePosition]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Transition, Object.assign({\n    appear: true,\n    nodeRef: nodeRef,\n    onEnter: handleEnter,\n    onEntered: onEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: handleExited,\n    \"in\": inProp,\n    timeout: timeout\n  }, other), function (state, childProps) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(children, _extends({\n      ref: handleRef,\n      style: _extends({\n        visibility: state === 'exited' && !inProp ? 'hidden' : undefined\n      }, style, {}, children.props.style)\n    }, childProps));\n  });\n});\nSlide.displayName = 'Slide';\n\nvar SvgIcon = function SvgIcon(props) {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", Object.assign({\n    viewBox: \"0 0 24 24\",\n    focusable: \"false\",\n    style: {\n      fontSize: 20,\n      marginInlineEnd: 8,\n      userSelect: 'none',\n      width: '1em',\n      height: '1em',\n      display: 'inline-block',\n      fill: 'currentColor',\n      flexShrink: 0\n    }\n  }, props));\n};\n\nvar CheckIcon = function CheckIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41\\n        10.59L10 14.17L17.59 6.58L19 8L10 17Z\"\n  }));\n};\n\nvar WarningIcon = function WarningIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z\"\n  }));\n};\n\nvar ErrorIcon = function ErrorIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,\\n        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,\\n        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z\"\n  }));\n};\n\nvar InfoIcon = function InfoIcon() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SvgIcon, null, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n    d: \"M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,\\n        0 22,12A10,10 0 0,0 12,2Z\"\n  }));\n};\n\nvar defaultIconVariants = {\n  \"default\": undefined,\n  success: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CheckIcon, null),\n  warning: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(WarningIcon, null),\n  error: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorIcon, null),\n  info: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InfoIcon, null)\n};\n\nvar defaults = {\n  maxSnack: 3,\n  persist: false,\n  hideIconVariant: false,\n  disableWindowBlurListener: false,\n  variant: 'default',\n  autoHideDuration: 5000,\n  iconVariant: defaultIconVariants,\n  anchorOrigin: {\n    vertical: 'bottom',\n    horizontal: 'left'\n  },\n  TransitionComponent: Slide,\n  transitionDuration: {\n    enter: 225,\n    exit: 195\n  }\n};\n/**\r\n * Derives the right autoHideDuration taking into account the following\r\n * prority order: 1: Options, 2: Props, 3: default fallback\r\n */\n\nvar getAutoHideDuration = function getAutoHideDuration(optionsDuration, propsDuration) {\n  var isNumberOrNull = function isNumberOrNull(numberish) {\n    return typeof numberish === 'number' || numberish === null;\n  };\n\n  if (isNumberOrNull(optionsDuration)) return optionsDuration;\n  if (isNumberOrNull(propsDuration)) return propsDuration;\n  return defaults.autoHideDuration;\n};\n/**\r\n * Derives the right transitionDuration taking into account the following\r\n * prority order: 1: Options, 2: Props, 3: default fallback\r\n */\n\n\nvar getTransitionDuration = function getTransitionDuration(optionsDuration, propsDuration) {\n  var is = function is(item, types) {\n    return types.some(function (t) {\n      return typeof item === t;\n    });\n  };\n\n  if (is(optionsDuration, ['string', 'number'])) {\n    return optionsDuration;\n  }\n\n  if (is(optionsDuration, ['object'])) {\n    return _extends({}, defaults.transitionDuration, {}, is(propsDuration, ['object']) && propsDuration, {}, optionsDuration);\n  }\n\n  if (is(propsDuration, ['string', 'number'])) {\n    return propsDuration;\n  }\n\n  if (is(propsDuration, ['object'])) {\n    return _extends({}, defaults.transitionDuration, {}, propsDuration);\n  }\n\n  return defaults.transitionDuration;\n};\n\nvar merge = function merge(options, props) {\n  return function (name, shouldObjectMerge) {\n    if (shouldObjectMerge === void 0) {\n      shouldObjectMerge = false;\n    }\n\n    if (shouldObjectMerge) {\n      return _extends({}, defaults[name], {}, props[name], {}, options[name]);\n    }\n\n    if (name === 'autoHideDuration') {\n      return getAutoHideDuration(options.autoHideDuration, props.autoHideDuration);\n    }\n\n    if (name === 'transitionDuration') {\n      return getTransitionDuration(options.transitionDuration, props.transitionDuration);\n    }\n\n    return options[name] || props[name] || defaults[name];\n  };\n};\n\nfunction makeStyles(styles) {\n  return Object.entries(styles).reduce(function (acc, _ref) {\n    var _extends2;\n\n    var key = _ref[0],\n        value = _ref[1];\n    return _extends({}, acc, (_extends2 = {}, _extends2[key] = (0,goober__WEBPACK_IMPORTED_MODULE_3__.css)(value), _extends2));\n  }, {});\n}\nvar ComponentClasses = {\n  SnackbarContainer: 'notistack-SnackbarContainer',\n  Snackbar: 'notistack-Snackbar',\n  CollapseWrapper: 'notistack-CollapseWrapper',\n  MuiContent: 'notistack-MuiContent',\n  MuiContentVariant: function MuiContentVariant(variant) {\n    return \"notistack-MuiContent-\" + variant;\n  }\n};\n\nvar classes = /*#__PURE__*/makeStyles({\n  root: {\n    height: 0\n  },\n  entered: {\n    height: 'auto'\n  }\n});\nvar collapsedSize = '0px';\nvar timeout = 175;\nvar Collapse = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var children = props.children,\n      inProp = props[\"in\"],\n      onExited = props.onExited;\n  var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var handleRef = useForkRef(ref, nodeRef);\n\n  var getWrapperSize = function getWrapperSize() {\n    return wrapperRef.current ? wrapperRef.current.clientHeight : 0;\n  };\n\n  var handleEnter = function handleEnter(node) {\n    node.style.height = collapsedSize;\n  };\n\n  var handleEntering = function handleEntering(node) {\n    var wrapperSize = getWrapperSize();\n\n    var _getTransitionProps = getTransitionProps({\n      timeout: timeout,\n      mode: 'enter'\n    }),\n        transitionDuration = _getTransitionProps.duration,\n        easing = _getTransitionProps.easing;\n\n    node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : transitionDuration + \"ms\";\n    node.style.height = wrapperSize + \"px\";\n    node.style.transitionTimingFunction = easing || '';\n  };\n\n  var handleEntered = function handleEntered(node) {\n    node.style.height = 'auto';\n  };\n\n  var handleExit = function handleExit(node) {\n    node.style.height = getWrapperSize() + \"px\";\n  };\n\n  var handleExiting = function handleExiting(node) {\n    reflow(node);\n\n    var _getTransitionProps2 = getTransitionProps({\n      timeout: timeout,\n      mode: 'exit'\n    }),\n        transitionDuration = _getTransitionProps2.duration,\n        easing = _getTransitionProps2.easing;\n\n    node.style.transitionDuration = typeof transitionDuration === 'string' ? transitionDuration : transitionDuration + \"ms\";\n    node.style.height = collapsedSize;\n    node.style.transitionTimingFunction = easing || '';\n  };\n\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Transition, {\n    \"in\": inProp,\n    unmountOnExit: true,\n    onEnter: handleEnter,\n    onEntered: handleEntered,\n    onEntering: handleEntering,\n    onExit: handleExit,\n    onExited: onExited,\n    onExiting: handleExiting,\n    nodeRef: nodeRef,\n    timeout: timeout\n  }, function (state, childProps) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({\n      ref: handleRef,\n      className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(classes.root, state === 'entered' && classes.entered),\n      style: _extends({\n        pointerEvents: 'all',\n        overflow: 'hidden',\n        minHeight: collapsedSize,\n        transition: createTransition('height')\n      }, state === 'entered' && {\n        overflow: 'visible'\n      }, {}, state === 'exited' && !inProp && {\n        visibility: 'hidden'\n      })\n    }, childProps), (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      ref: wrapperRef,\n      className: ComponentClasses.CollapseWrapper,\n      // Hack to get children with a negative margin to not falsify the height computation.\n      style: {\n        display: 'flex',\n        width: '100%'\n      }\n    }, children));\n  });\n});\nCollapse.displayName = 'Collapse';\n\nvar direction = {\n  right: 'left',\n  left: 'right',\n  bottom: 'up',\n  top: 'down'\n};\nvar getSlideDirection = function getSlideDirection(anchorOrigin) {\n  if (anchorOrigin.horizontal !== 'center') {\n    return direction[anchorOrigin.horizontal];\n  }\n\n  return direction[anchorOrigin.vertical];\n};\n/** Tranforms classes name */\n\nvar toSnackbarAnchorOrigin = function toSnackbarAnchorOrigin(anchorOrigin) {\n  return \"anchorOrigin\" + originKeyExtractor(anchorOrigin);\n};\n/**\r\n * Omit SnackbarContainer class keys that are not needed for SnackbarItem\r\n */\n\nvar keepSnackbarClassKeys = function keepSnackbarClassKeys(classes) {\n  if (classes === void 0) {\n    classes = {};\n  }\n\n  var containerClasses = {\n    containerRoot: true,\n    containerAnchorOriginTopCenter: true,\n    containerAnchorOriginBottomCenter: true,\n    containerAnchorOriginTopRight: true,\n    containerAnchorOriginBottomRight: true,\n    containerAnchorOriginTopLeft: true,\n    containerAnchorOriginBottomLeft: true\n  };\n  return Object.keys(classes).filter(function (key) {\n    return !containerClasses[key];\n  }).reduce(function (obj, key) {\n    var _extends2;\n\n    return _extends({}, obj, (_extends2 = {}, _extends2[key] = classes[key], _extends2));\n  }, {});\n};\n\nvar noOp$1 = function noOp() {\n  /* */\n};\n/**\r\n * Credit to MUI team @ https://mui.com\r\n * Safe chained function.\r\n *\r\n * Will only create a new function if needed,\r\n * otherwise will pass back existing functions or null.\r\n */\n\n\nfunction createChainedFunction(funcs, snackbarId) {\n  // @ts-ignore\n  return funcs.reduce(function (acc, func) {\n    if (func === null || func === undefined) {\n      return acc;\n    }\n\n    return function chainedFunction() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var argums = [].concat(args);\n\n      if (snackbarId && argums.indexOf(snackbarId) === -1) {\n        argums.push(snackbarId);\n      } // @ts-ignore\n\n\n      acc.apply(this, argums);\n      func.apply(this, argums);\n    };\n  }, noOp$1);\n}\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\r\n */\nvar useEnhancedEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useEventCallback(fn) {\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fn);\n  useEnhancedEffect(function () {\n    ref.current = fn;\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    return (// @ts-expect-error hide `this`\n      (ref.current).apply(void 0, arguments)\n    );\n  }, []);\n}\n\n/**\r\n * Credit to MUI team @ https://mui.com\r\n */\nvar Snackbar = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var children = props.children,\n      className = props.className,\n      autoHideDuration = props.autoHideDuration,\n      _props$disableWindowB = props.disableWindowBlurListener,\n      disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB,\n      onClose = props.onClose,\n      id = props.id,\n      open = props.open,\n      _props$SnackbarProps = props.SnackbarProps,\n      SnackbarProps = _props$SnackbarProps === void 0 ? {} : _props$SnackbarProps;\n  var timerAutoHide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var handleClose = useEventCallback(function () {\n    if (onClose) {\n      onClose.apply(void 0, arguments);\n    }\n  });\n  var setAutoHideTimer = useEventCallback(function (autoHideDurationParam) {\n    if (!onClose || autoHideDurationParam == null) {\n      return;\n    }\n\n    if (timerAutoHide.current) {\n      clearTimeout(timerAutoHide.current);\n    }\n\n    timerAutoHide.current = setTimeout(function () {\n      handleClose(null, 'timeout', id);\n    }, autoHideDurationParam);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (open) {\n      setAutoHideTimer(autoHideDuration);\n    }\n\n    return function () {\n      if (timerAutoHide.current) {\n        clearTimeout(timerAutoHide.current);\n      }\n    };\n  }, [open, autoHideDuration, setAutoHideTimer]);\n  /**\r\n   * Pause the timer when the user is interacting with the Snackbar\r\n   * or when the user hide the window.\r\n   */\n\n  var handlePause = function handlePause() {\n    if (timerAutoHide.current) {\n      clearTimeout(timerAutoHide.current);\n    }\n  };\n  /**\r\n   * Restart the timer when the user is no longer interacting with the Snackbar\r\n   * or when the window is shown back.\r\n   */\n\n\n  var handleResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    if (autoHideDuration != null) {\n      setAutoHideTimer(autoHideDuration * 0.5);\n    }\n  }, [autoHideDuration, setAutoHideTimer]);\n\n  var handleMouseEnter = function handleMouseEnter(event) {\n    if (SnackbarProps.onMouseEnter) {\n      SnackbarProps.onMouseEnter(event);\n    }\n\n    handlePause();\n  };\n\n  var handleMouseLeave = function handleMouseLeave(event) {\n    if (SnackbarProps.onMouseLeave) {\n      SnackbarProps.onMouseLeave(event);\n    }\n\n    handleResume();\n  };\n\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    if (!disableWindowBlurListener && open) {\n      window.addEventListener('focus', handleResume);\n      window.addEventListener('blur', handlePause);\n      return function () {\n        window.removeEventListener('focus', handleResume);\n        window.removeEventListener('blur', handlePause);\n      };\n    }\n\n    return undefined;\n  }, [disableWindowBlurListener, handleResume, open]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({\n    ref: ref\n  }, SnackbarProps, {\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ComponentClasses.Snackbar, className),\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave\n  }), children);\n});\nSnackbar.displayName = 'Snackbar';\n\nvar _root;\nvar classes$1 = /*#__PURE__*/makeStyles({\n  root: (_root = {\n    display: 'flex',\n    flexWrap: 'wrap',\n    flexGrow: 1\n  }, _root[breakpoints.upSm] = {\n    flexGrow: 'initial',\n    minWidth: '288px'\n  }, _root)\n});\nvar SnackbarContent = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_ref, ref) {\n  var className = _ref.className,\n      props = _objectWithoutPropertiesLoose(_ref, [\"className\"]);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", Object.assign({\n    ref: ref,\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(classes$1.root, className)\n  }, props));\n});\nSnackbarContent.displayName = 'SnackbarContent';\n\nvar classes$2 = /*#__PURE__*/makeStyles({\n  root: {\n    backgroundColor: '#313131',\n    fontSize: '0.875rem',\n    lineHeight: 1.43,\n    letterSpacing: '0.01071em',\n    color: '#fff',\n    alignItems: 'center',\n    padding: '6px 16px',\n    borderRadius: '4px',\n    boxShadow: '0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)'\n  },\n  lessPadding: {\n    paddingLeft: 8 * 2.5 + \"px\"\n  },\n  \"default\": {\n    backgroundColor: '#313131'\n  },\n  success: {\n    backgroundColor: '#43a047'\n  },\n  error: {\n    backgroundColor: '#d32f2f'\n  },\n  warning: {\n    backgroundColor: '#ff9800'\n  },\n  info: {\n    backgroundColor: '#2196f3'\n  },\n  message: {\n    display: 'flex',\n    alignItems: 'center',\n    padding: '8px 0'\n  },\n  action: {\n    display: 'flex',\n    alignItems: 'center',\n    marginLeft: 'auto',\n    paddingLeft: '16px',\n    marginRight: '-8px'\n  }\n});\nvar ariaDescribedby = 'notistack-snackbar';\nvar MaterialDesignContent = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, forwardedRef) {\n  var id = props.id,\n      message = props.message,\n      componentOrFunctionAction = props.action,\n      iconVariant = props.iconVariant,\n      variant = props.variant,\n      hideIconVariant = props.hideIconVariant,\n      style = props.style,\n      className = props.className;\n  var icon = iconVariant[variant];\n  var action = componentOrFunctionAction;\n\n  if (typeof action === 'function') {\n    action = action(id);\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarContent, {\n    ref: forwardedRef,\n    role: \"alert\",\n    \"aria-describedby\": ariaDescribedby,\n    style: style,\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ComponentClasses.MuiContent, ComponentClasses.MuiContentVariant(variant), classes$2.root, classes$2[variant], className, !hideIconVariant && icon && classes$2.lessPadding)\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    id: ariaDescribedby,\n    className: classes$2.message\n  }, !hideIconVariant ? icon : null, message), action && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: classes$2.action\n  }, action));\n});\nMaterialDesignContent.displayName = 'MaterialDesignContent';\nvar MaterialDesignContent$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(MaterialDesignContent);\n\nvar styles = /*#__PURE__*/makeStyles({\n  wrappedRoot: {\n    width: '100%',\n    position: 'relative',\n    transform: 'translateX(0)',\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    minWidth: '288px'\n  }\n});\n\nvar SnackbarItem = function SnackbarItem(props) {\n  var timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true),\n      collapsed = _useState[0],\n      setCollapsed = _useState[1];\n\n  var handleClose = createChainedFunction([props.snack.onClose, props.onClose]);\n\n  var handleEntered = function handleEntered() {\n    if (props.snack.requestClose) {\n      handleClose(null, 'instructed', props.snack.id);\n    }\n  };\n\n  var handleExitedScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n    timeout.current = setTimeout(function () {\n      setCollapsed(function (col) {\n        return !col;\n      });\n    }, 125);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    return function () {\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n  var snack = props.snack,\n      allClasses = props.classes,\n      _props$Component = props.Component,\n      Component = _props$Component === void 0 ? MaterialDesignContent$1 : _props$Component;\n  var classes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n    return keepSnackbarClassKeys(allClasses);\n  }, [allClasses]);\n\n  var open = snack.open,\n      SnackbarProps = snack.SnackbarProps,\n      TransitionComponent = snack.TransitionComponent,\n      TransitionProps = snack.TransitionProps,\n      transitionDuration = snack.transitionDuration,\n      disableWindowBlurListener = snack.disableWindowBlurListener,\n      componentOrFunctionContent = snack.content,\n      otherSnack = _objectWithoutPropertiesLoose(snack, [\"open\", \"SnackbarProps\", \"TransitionComponent\", \"TransitionProps\", \"transitionDuration\", \"disableWindowBlurListener\", \"content\", \"entered\", \"requestClose\", \"onEnter\", \"onEntered\", \"onExit\", \"onExited\"]);\n\n  var transitionProps = _extends({\n    direction: getSlideDirection(otherSnack.anchorOrigin),\n    timeout: transitionDuration\n  }, TransitionProps);\n\n  var content = componentOrFunctionContent;\n\n  if (typeof content === 'function') {\n    content = content(otherSnack.id, otherSnack.message);\n  }\n\n  var callbacks = ['onEnter', 'onEntered', 'onExit', 'onExited'].reduce(function (acc, cbName) {\n    var _extends2;\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[cbName] = createChainedFunction([props.snack[cbName], props[cbName]], otherSnack.id), _extends2));\n  }, {});\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Collapse, {\n    \"in\": collapsed,\n    onExited: callbacks.onExited\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Snackbar, {\n    open: open,\n    id: otherSnack.id,\n    disableWindowBlurListener: disableWindowBlurListener,\n    autoHideDuration: otherSnack.autoHideDuration,\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(styles.wrappedRoot, classes.root, classes[toSnackbarAnchorOrigin(otherSnack.anchorOrigin)]),\n    SnackbarProps: SnackbarProps,\n    onClose: handleClose\n  }, react__WEBPACK_IMPORTED_MODULE_0___default().createElement(TransitionComponent, Object.assign({}, transitionProps, {\n    appear: true,\n    \"in\": open,\n    onExit: callbacks.onExit,\n    onExited: handleExitedScreen,\n    onEnter: callbacks.onEnter,\n    // order matters. first callbacks.onEntered to set entered: true,\n    // then handleEntered to check if there's a request for closing\n    onEntered: createChainedFunction([callbacks.onEntered, handleEntered], otherSnack.id)\n  }), content || react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Component, Object.assign({}, otherSnack)))));\n};\n\nvar _root$1, _rootDense, _left, _right, _center;\nvar indents = {\n  view: {\n    \"default\": 20,\n    dense: 4\n  },\n  snackbar: {\n    \"default\": 6,\n    dense: 2\n  }\n};\nvar collapseWrapper = \".\" + ComponentClasses.CollapseWrapper;\nvar xsWidthMargin = 16;\nvar styles$1 = /*#__PURE__*/makeStyles({\n  root: (_root$1 = {\n    boxSizing: 'border-box',\n    display: 'flex',\n    maxHeight: '100%',\n    position: 'fixed',\n    zIndex: 1400,\n    height: 'auto',\n    width: 'auto',\n    transition: /*#__PURE__*/createTransition(['top', 'right', 'bottom', 'left', 'max-width'], {\n      duration: 300,\n      easing: 'ease'\n    }),\n    // container itself is invisible and should not block clicks, clicks should be passed to its children\n    // a pointerEvents: all is applied in the collapse component\n    pointerEvents: 'none'\n  }, _root$1[collapseWrapper] = {\n    padding: indents.snackbar[\"default\"] + \"px 0px\",\n    transition: 'padding 300ms ease 0ms'\n  }, _root$1.maxWidth = \"calc(100% - \" + indents.view[\"default\"] * 2 + \"px)\", _root$1[breakpoints.downXs] = {\n    width: '100%',\n    maxWidth: \"calc(100% - \" + xsWidthMargin * 2 + \"px)\"\n  }, _root$1),\n  rootDense: (_rootDense = {}, _rootDense[collapseWrapper] = {\n    padding: indents.snackbar.dense + \"px 0px\"\n  }, _rootDense),\n  top: {\n    top: indents.view[\"default\"] - indents.snackbar[\"default\"] + \"px\",\n    flexDirection: 'column'\n  },\n  bottom: {\n    bottom: indents.view[\"default\"] - indents.snackbar[\"default\"] + \"px\",\n    flexDirection: 'column-reverse'\n  },\n  left: (_left = {\n    left: indents.view[\"default\"] + \"px\"\n  }, _left[breakpoints.upSm] = {\n    alignItems: 'flex-start'\n  }, _left[breakpoints.downXs] = {\n    left: xsWidthMargin + \"px\"\n  }, _left),\n  right: (_right = {\n    right: indents.view[\"default\"] + \"px\"\n  }, _right[breakpoints.upSm] = {\n    alignItems: 'flex-end'\n  }, _right[breakpoints.downXs] = {\n    right: xsWidthMargin + \"px\"\n  }, _right),\n  center: (_center = {\n    left: '50%',\n    transform: 'translateX(-50%)'\n  }, _center[breakpoints.upSm] = {\n    alignItems: 'center'\n  }, _center)\n});\n\nvar SnackbarContainer = function SnackbarContainer(props) {\n  var _props$classes = props.classes,\n      classes = _props$classes === void 0 ? {} : _props$classes,\n      anchorOrigin = props.anchorOrigin,\n      dense = props.dense,\n      children = props.children;\n  var combinedClassname = (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ComponentClasses.SnackbarContainer, styles$1[anchorOrigin.vertical], styles$1[anchorOrigin.horizontal], styles$1.root, // root should come after others to override maxWidth\n  classes.containerRoot, classes[\"containerAnchorOrigin\" + originKeyExtractor(anchorOrigin)], dense && styles$1.rootDense);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: combinedClassname\n  }, children);\n};\n\nvar SnackbarContainer$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SnackbarContainer);\n\n/* eslint-disable */\nvar __DEV__ = \"development\" !== 'production';\n\nvar messages = {\n  NO_PERSIST_ALL: \"Reached maxSnack while all enqueued snackbars have 'persist' flag. Notistack will dismiss the oldest snackbar anyway to allow other ones in the queue to be presented.\"\n};\nvar warning = (function (messageKey) {\n  if (!__DEV__) return;\n  var message = messages[messageKey];\n\n  if (typeof console !== 'undefined') {\n    console.error(\"WARNING - notistack: \" + message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n});\n\nvar isOptions = function isOptions(messageOrOptions) {\n  var isMessage = typeof messageOrOptions === 'string' || (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(messageOrOptions);\n  return !isMessage;\n};\n\nvar enqueueSnackbar;\nvar closeSnackbar;\n\nvar SnackbarProvider = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(SnackbarProvider, _Component);\n\n  function SnackbarProvider(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    /**\r\n     * Adds a new snackbar to the queue to be presented.\r\n     * Returns generated or user defined key referencing the new snackbar or null\r\n     */\n\n    _this.enqueueSnackbar = function (messageOrOptions, optsOrUndefined) {\n      if (optsOrUndefined === void 0) {\n        optsOrUndefined = {};\n      }\n\n      if (messageOrOptions === undefined || messageOrOptions === null) {\n        throw new Error('enqueueSnackbar called with invalid argument');\n      }\n\n      var opts = isOptions(messageOrOptions) ? messageOrOptions : optsOrUndefined;\n      var message = isOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions;\n\n      var key = opts.key,\n          preventDuplicate = opts.preventDuplicate,\n          options = _objectWithoutPropertiesLoose(opts, [\"key\", \"preventDuplicate\"]);\n\n      var hasSpecifiedKey = isDefined(key);\n      var id = hasSpecifiedKey ? key : new Date().getTime() + Math.random();\n      var merger = merge(options, _this.props);\n\n      var snack = _extends({\n        id: id\n      }, options, {\n        message: message,\n        open: true,\n        entered: false,\n        requestClose: false,\n        persist: merger('persist'),\n        action: merger('action'),\n        content: merger('content'),\n        variant: merger('variant'),\n        anchorOrigin: merger('anchorOrigin'),\n        disableWindowBlurListener: merger('disableWindowBlurListener'),\n        autoHideDuration: merger('autoHideDuration'),\n        hideIconVariant: merger('hideIconVariant'),\n        TransitionComponent: merger('TransitionComponent'),\n        transitionDuration: merger('transitionDuration'),\n        TransitionProps: merger('TransitionProps', true),\n        iconVariant: merger('iconVariant', true),\n        style: merger('style', true),\n        SnackbarProps: merger('SnackbarProps', true),\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_this.props.className, options.className)\n      });\n\n      if (snack.persist) {\n        snack.autoHideDuration = undefined;\n      }\n\n      _this.setState(function (state) {\n        if (preventDuplicate === undefined && _this.props.preventDuplicate || preventDuplicate) {\n          var compareFunction = function compareFunction(item) {\n            return hasSpecifiedKey ? item.id === id : item.message === message;\n          };\n\n          var inQueue = state.queue.findIndex(compareFunction) > -1;\n          var inView = state.snacks.findIndex(compareFunction) > -1;\n\n          if (inQueue || inView) {\n            return state;\n          }\n        }\n\n        return _this.handleDisplaySnack(_extends({}, state, {\n          queue: [].concat(state.queue, [snack])\n        }));\n      });\n\n      return id;\n    };\n    /**\r\n     * Reducer: Display snack if there's space for it. Otherwise, immediately\r\n     * begin dismissing the oldest message to start showing the new one.\r\n     */\n\n\n    _this.handleDisplaySnack = function (state) {\n      var snacks = state.snacks;\n\n      if (snacks.length >= _this.maxSnack) {\n        return _this.handleDismissOldest(state);\n      }\n\n      return _this.processQueue(state);\n    };\n    /**\r\n     * Reducer: Display items (notifications) in the queue if there's space for them.\r\n     */\n\n\n    _this.processQueue = function (state) {\n      var queue = state.queue,\n          snacks = state.snacks;\n\n      if (queue.length > 0) {\n        return _extends({}, state, {\n          snacks: [].concat(snacks, [queue[0]]),\n          queue: queue.slice(1, queue.length)\n        });\n      }\n\n      return state;\n    };\n    /**\r\n     * Reducer: Hide oldest snackbar on the screen because there exists a new one which we have to display.\r\n     * (ignoring the one with 'persist' flag. i.e. explicitly told by user not to get dismissed).\r\n     *\r\n     * Note 1: If there is already a message leaving the screen, no new messages are dismissed.\r\n     * Note 2: If the oldest message has not yet entered the screen, only a request to close the\r\n     *         snackbar is made. Once it entered the screen, it will be immediately dismissed.\r\n     */\n\n\n    _this.handleDismissOldest = function (state) {\n      if (state.snacks.some(function (item) {\n        return !item.open || item.requestClose;\n      })) {\n        return state;\n      }\n\n      var popped = false;\n      var ignore = false;\n      var persistentCount = state.snacks.reduce(function (acc, current) {\n        return acc + (current.open && current.persist ? 1 : 0);\n      }, 0);\n\n      if (persistentCount === _this.maxSnack) {\n         true ? warning('NO_PERSIST_ALL') : 0;\n        ignore = true;\n      }\n\n      var snacks = state.snacks.map(function (item) {\n        if (!popped && (!item.persist || ignore)) {\n          popped = true;\n\n          if (!item.entered) {\n            return _extends({}, item, {\n              requestClose: true\n            });\n          }\n\n          if (item.onClose) {\n            item.onClose(null, 'maxsnack', item.id);\n          }\n\n          if (_this.props.onClose) {\n            _this.props.onClose(null, 'maxsnack', item.id);\n          }\n\n          return _extends({}, item, {\n            open: false\n          });\n        }\n\n        return _extends({}, item);\n      });\n      return _extends({}, state, {\n        snacks: snacks\n      });\n    };\n    /**\r\n     * Set the entered state of the snackbar with the given key.\r\n     */\n\n\n    _this.handleEnteredSnack = function (node, isAppearing, key) {\n      if (!isDefined(key)) {\n        throw new Error('handleEnteredSnack Cannot be called with undefined key');\n      }\n\n      _this.setState(function (_ref) {\n        var snacks = _ref.snacks;\n        return {\n          snacks: snacks.map(function (item) {\n            return item.id === key ? _extends({}, item, {\n              entered: true\n            }) : _extends({}, item);\n          })\n        };\n      });\n    };\n    /**\r\n     * Hide a snackbar after its timeout.\r\n     */\n\n\n    _this.handleCloseSnack = function (event, reason, key) {\n      // should not use createChainedFunction for onClose.\n      // because this.closeSnackbar called this function\n      if (_this.props.onClose) {\n        _this.props.onClose(event, reason, key);\n      }\n\n      var shouldCloseAll = key === undefined;\n\n      _this.setState(function (_ref2) {\n        var snacks = _ref2.snacks,\n            queue = _ref2.queue;\n        return {\n          snacks: snacks.map(function (item) {\n            if (!shouldCloseAll && item.id !== key) {\n              return _extends({}, item);\n            }\n\n            return item.entered ? _extends({}, item, {\n              open: false\n            }) : _extends({}, item, {\n              requestClose: true\n            });\n          }),\n          queue: queue.filter(function (item) {\n            return item.id !== key;\n          })\n        };\n      });\n    };\n    /**\r\n     * Close snackbar with the given key\r\n     */\n\n\n    _this.closeSnackbar = function (key) {\n      // call individual snackbar onClose callback passed through options parameter\n      var toBeClosed = _this.state.snacks.find(function (item) {\n        return item.id === key;\n      });\n\n      if (isDefined(key) && toBeClosed && toBeClosed.onClose) {\n        toBeClosed.onClose(null, 'instructed', key);\n      }\n\n      _this.handleCloseSnack(null, 'instructed', key);\n    };\n    /**\r\n     * When we set open attribute of a snackbar to false (i.e. after we hide a snackbar),\r\n     * it leaves the screen and immediately after leaving animation is done, this method\r\n     * gets called. We remove the hidden snackbar from state and then display notifications\r\n     * waiting in the queue (if any). If after this process the queue is not empty, the\r\n     * oldest message is dismissed.\r\n     */\n\n\n    _this.handleExitedSnack = function (node, key) {\n      if (!isDefined(key)) {\n        throw new Error('handleExitedSnack Cannot be called with undefined key');\n      }\n\n      _this.setState(function (state) {\n        var newState = _this.processQueue(_extends({}, state, {\n          snacks: state.snacks.filter(function (item) {\n            return item.id !== key;\n          })\n        }));\n\n        if (newState.queue.length === 0) {\n          return newState;\n        }\n\n        return _this.handleDismissOldest(newState);\n      });\n    };\n\n    enqueueSnackbar = _this.enqueueSnackbar;\n    closeSnackbar = _this.closeSnackbar;\n    _this.state = {\n      snacks: [],\n      queue: [],\n      contextValue: {\n        enqueueSnackbar: _this.enqueueSnackbar.bind(_assertThisInitialized(_this)),\n        closeSnackbar: _this.closeSnackbar.bind(_assertThisInitialized(_this))\n      }\n    };\n    return _this;\n  }\n\n  var _proto = SnackbarProvider.prototype;\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var contextValue = this.state.contextValue;\n    var _this$props = this.props,\n        domRoot = _this$props.domRoot,\n        children = _this$props.children,\n        _this$props$dense = _this$props.dense,\n        dense = _this$props$dense === void 0 ? false : _this$props$dense,\n        _this$props$Component = _this$props.Components,\n        Components = _this$props$Component === void 0 ? {} : _this$props$Component,\n        classes = _this$props.classes;\n    var categ = this.state.snacks.reduce(function (acc, current) {\n      var _extends2;\n\n      var category = originKeyExtractor(current.anchorOrigin);\n      var existingOfCategory = acc[category] || [];\n      return _extends({}, acc, (_extends2 = {}, _extends2[category] = [].concat(existingOfCategory, [current]), _extends2));\n    }, {});\n    var snackbars = Object.keys(categ).map(function (origin) {\n      var snacks = categ[origin];\n      var nomineeSnack = snacks[0];\n      return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarContainer$1, {\n        key: origin,\n        dense: dense,\n        anchorOrigin: nomineeSnack.anchorOrigin,\n        classes: classes\n      }, snacks.map(function (snack) {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarItem, {\n          key: snack.id,\n          snack: snack,\n          classes: classes,\n          Component: Components[snack.variant],\n          onClose: _this2.handleCloseSnack,\n          onEnter: _this2.props.onEnter,\n          onExit: _this2.props.onExit,\n          onExited: createChainedFunction([_this2.handleExitedSnack, _this2.props.onExited], snack.id),\n          onEntered: createChainedFunction([_this2.handleEnteredSnack, _this2.props.onEntered], snack.id)\n        });\n      }));\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SnackbarContext.Provider, {\n      value: contextValue\n    }, children, domRoot ? (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(snackbars, domRoot) : snackbars);\n  };\n\n  _createClass(SnackbarProvider, [{\n    key: \"maxSnack\",\n    get: function get() {\n      return this.props.maxSnack || defaults.maxSnack;\n    }\n  }]);\n\n  return SnackbarProvider;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nvar useSnackbar = (function () {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SnackbarContext);\n});\n\n\n//# sourceMappingURL=notistack.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm90aXN0YWNrL25vdGlzdGFjay5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFpTTtBQUN4SjtBQUNqQjtBQUNLOztBQUU3QjtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQywwREFBNEI7QUFDL0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QyxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBEQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlLDBEQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxXQUFXLDBEQUE0QjtBQUN2QztBQUNBLEtBQUssc0JBQXNCLHVEQUFZO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxDQUFDLDRDQUFTOztBQUVYO0FBQ0EsU0FBUyxpREFBVTtBQUNuQixDQUFDOztBQUV1SjtBQUN4SiIsInNvdXJjZXMiOlsiL1VzZXJzL21vaGFtZWRhaG1lZC9Eb2N1bWVudHMvR2l0SHViL1N1cGVyLXNoZWV0LWFkbWluLUZFL25vZGVfbW9kdWxlcy9ub3Rpc3RhY2svbm90aXN0YWNrLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlTWVtbywgZm9yd2FyZFJlZiwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQsIHVzZUxheW91dEVmZmVjdCwgbWVtbywgdXNlU3RhdGUsIENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdnb29iZXInO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbnZhciBub09wID0gZnVuY3Rpb24gbm9PcCgpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIFNuYWNrYmFyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHtcbiAgZW5xdWV1ZVNuYWNrYmFyOiBub09wLFxuICBjbG9zZVNuYWNrYmFyOiBub09wXG59KTtcblxudmFyIGJyZWFrcG9pbnRzID0ge1xuICBkb3duWHM6ICdAbWVkaWEgKG1heC13aWR0aDo1OTkuOTVweCknLFxuICB1cFNtOiAnQG1lZGlhIChtaW4td2lkdGg6NjAwcHgpJ1xufTtcblxudmFyIGNhcGl0YWxpc2UgPSBmdW5jdGlvbiBjYXBpdGFsaXNlKHRleHQpIHtcbiAgcmV0dXJuIHRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnNsaWNlKDEpO1xufTtcblxudmFyIG9yaWdpbktleUV4dHJhY3RvciA9IGZ1bmN0aW9uIG9yaWdpbktleUV4dHJhY3RvcihhbmNob3IpIHtcbiAgcmV0dXJuIFwiXCIgKyBjYXBpdGFsaXNlKGFuY2hvci52ZXJ0aWNhbCkgKyBjYXBpdGFsaXNlKGFuY2hvci5ob3Jpem9udGFsKTtcbn07XG52YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSAwO1xufTtcblxudmFyIFVOTU9VTlRFRCA9ICd1bm1vdW50ZWQnO1xudmFyIEVYSVRFRCA9ICdleGl0ZWQnO1xudmFyIEVOVEVSSU5HID0gJ2VudGVyaW5nJztcbnZhciBFTlRFUkVEID0gJ2VudGVyZWQnO1xudmFyIEVYSVRJTkcgPSAnZXhpdGluZyc7XG5cbnZhciBUcmFuc2l0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24ocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICB2YXIgYXBwZWFyID0gcHJvcHMuYXBwZWFyO1xuICAgIHZhciBpbml0aWFsU3RhdHVzO1xuICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJvcHNbXCJpblwiXSkge1xuICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBFTlRFUklORztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFTlRFUkVEO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHMudW5tb3VudE9uRXhpdCB8fCBwcm9wcy5tb3VudE9uRW50ZXIpIHtcbiAgICAgIGluaXRpYWxTdGF0dXMgPSBVTk1PVU5URUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgfVxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBzdGF0dXM6IGluaXRpYWxTdGF0dXNcbiAgICB9O1xuICAgIF90aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVHJhbnNpdGlvbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiwgcHJldlN0YXRlKSB7XG4gICAgdmFyIG5leHRJbiA9IF9yZWZbXCJpblwiXTtcblxuICAgIGlmIChuZXh0SW4gJiYgcHJldlN0YXRlLnN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0dXModHJ1ZSwgdGhpcy5hcHBlYXJTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIG5leHRTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgICBpZiAodGhpcy5wcm9wc1tcImluXCJdKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklORztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElORztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyhmYWxzZSwgbmV4dFN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGltZW91dHMgPSBmdW5jdGlvbiBnZXRUaW1lb3V0cygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICB2YXIgZW50ZXIgPSB0aW1lb3V0O1xuICAgIHZhciBleGl0ID0gdGltZW91dDtcblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwgJiYgdHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInICYmIHR5cGVvZiB0aW1lb3V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgZXhpdCA9IHRpbWVvdXQuZXhpdDtcbiAgICAgIGVudGVyID0gdGltZW91dC5lbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpdDogZXhpdCxcbiAgICAgIGVudGVyOiBlbnRlclxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXR1cyhtb3VudGluZywgbmV4dFN0YXR1cykge1xuICAgIGlmIChtb3VudGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBtb3VudGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZXh0U3RhdHVzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuXG4gICAgICBpZiAobmV4dFN0YXR1cyA9PT0gRU5URVJJTkcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRW50ZXIobW91bnRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXhpdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy51bm1vdW50T25FeGl0ICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSBFWElURUQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFVOTU9VTlRFRFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRW50ZXIgPSBmdW5jdGlvbiBwZXJmb3JtRW50ZXIobW91bnRpbmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBlbnRlciA9IHRoaXMucHJvcHMuZW50ZXI7XG4gICAgdmFyIGlzQXBwZWFyaW5nID0gbW91bnRpbmc7XG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpO1xuXG4gICAgaWYgKCFtb3VudGluZyAmJiAhZW50ZXIpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIucHJvcHMub25FbnRlcmVkKSB7XG4gICAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChfdGhpczIubm9kZSwgaXNBcHBlYXJpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkVudGVyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRW50ZXIodGhpcy5ub2RlLCBpc0FwcGVhcmluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFTlRFUklOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIucHJvcHMub25FbnRlcmluZykge1xuICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmluZyhfdGhpczIubm9kZSwgaXNBcHBlYXJpbmcpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczIub25UcmFuc2l0aW9uRW5kKHRpbWVvdXRzLmVudGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5wcm9wcy5vbkVudGVyZWQpIHtcbiAgICAgICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQoX3RoaXMyLm5vZGUsIGlzQXBwZWFyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FeGl0ID0gZnVuY3Rpb24gcGVyZm9ybUV4aXQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgZXhpdCA9IHRoaXMucHJvcHMuZXhpdDtcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7IC8vIG5vIGV4aXQgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRVhJVEVEXG5cbiAgICBpZiAoIWV4aXQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChfdGhpczMubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm9uRXhpdCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkV4aXQodGhpcy5ub2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVYSVRJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMzLnByb3BzLm9uRXhpdGluZykge1xuICAgICAgICBfdGhpczMucHJvcHMub25FeGl0aW5nKF90aGlzMy5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMzLm9uVHJhbnNpdGlvbkVuZCh0aW1lb3V0cy5leGl0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLnByb3BzLm9uRXhpdGVkKSB7XG4gICAgICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQoX3RoaXMzLm5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsTmV4dENhbGxiYWNrID0gZnVuY3Rpb24gY2FuY2VsTmV4dENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLm5leHRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwpIHtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCgpO1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2FmZVNldFN0YXRlID0gZnVuY3Rpb24gc2FmZVNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHRoaXMuc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBzZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBhY3RpdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpczQubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm5leHRDYWxsYmFjaztcbiAgfTtcblxuICBfcHJvdG8ub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKHRpbWVvdXQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnNldE5leHRDYWxsYmFjayhoYW5kbGVyKTtcbiAgICB2YXIgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lciA9IHRpbWVvdXQgPT0gbnVsbCAmJiAhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtcblxuICAgIGlmICghdGhpcy5ub2RlIHx8IGRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKSB7XG4gICAgICB0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKHRoaXMubm9kZSwgdGhpcy5uZXh0Q2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgIGlmIChzdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY2hpbGRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluXCIsIFwibW91bnRPbkVudGVyXCIsIFwidW5tb3VudE9uRXhpdFwiLCBcImFwcGVhclwiLCBcImVudGVyXCIsIFwiZXhpdFwiLCBcInRpbWVvdXRcIiwgXCJhZGRFbmRMaXN0ZW5lclwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyaW5nXCIsIFwib25FbnRlcmVkXCIsIFwib25FeGl0XCIsIFwib25FeGl0aW5nXCIsIFwib25FeGl0ZWRcIiwgXCJub2RlUmVmXCJdKTtcblxuICAgIHJldHVybiBjaGlsZHJlbihzdGF0dXMsIGNoaWxkUHJvcHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhUcmFuc2l0aW9uLCBbe1xuICAgIGtleTogXCJub2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMkbm9kZVJlZjtcblxuICAgICAgdmFyIG5vZGUgPSAoX3RoaXMkcHJvcHMkbm9kZVJlZiA9IHRoaXMucHJvcHMubm9kZVJlZikgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkbm9kZVJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkbm9kZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Rpc3RhY2sgLSBDdXN0b20gc25hY2tiYXIgaXMgbm90IHJlZkZvcndhcmRpbmcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zaXRpb247XG59KFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7Ly9cbn1cblxuVHJhbnNpdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIFwiaW5cIjogZmFsc2UsXG4gIG1vdW50T25FbnRlcjogZmFsc2UsXG4gIHVubW91bnRPbkV4aXQ6IGZhbHNlLFxuICBhcHBlYXI6IGZhbHNlLFxuICBlbnRlcjogdHJ1ZSxcbiAgZXhpdDogdHJ1ZSxcbiAgb25FbnRlcjogbm9vcCxcbiAgb25FbnRlcmluZzogbm9vcCxcbiAgb25FbnRlcmVkOiBub29wLFxuICBvbkV4aXQ6IG5vb3AsXG4gIG9uRXhpdGluZzogbm9vcCxcbiAgb25FeGl0ZWQ6IG5vb3Bcbn07XG5cbi8qKlxyXG4gKiBDcmVkaXQgdG8gTVVJIHRlYW0gQCBodHRwczovL211aS5jb21cclxuICovXG4vKipcclxuICogcGFzc2VzIHt2YWx1ZX0gdG8ge3JlZn1cclxuICpcclxuICogVXNlZnVsIGlmIHlvdSB3YW50IHRvIGV4cG9zZSB0aGUgcmVmIG9mIGFuIGlubmVyIGNvbXBvbmVudCB0byB0aGUgcHVibGljIEFQSVxyXG4gKiB3aGlsZSBzdGlsbCB1c2luZyBpdCBpbnNpZGUgdGhlIGNvbXBvbmVudC5cclxuICogQHBhcmFtIHJlZiBBIHJlZiBjYWxsYmFjayBvciByZWYgb2JqZWN0LiBJZiBhbnl0aGluZyBmYWxzeSwgdGhpcyBpcyBhIG5vLW9wLlxyXG4gKi9cblxuZnVuY3Rpb24gc2V0UmVmKHJlZiwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYodmFsdWUpO1xuICB9IGVsc2UgaWYgKHJlZikge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRm9ya1JlZihyZWZBLCByZWZCKSB7XG4gIC8qKlxyXG4gICAqIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gaWYgdGhlIHJlZiBwcm9wcyBjaGFuZ2UgYW5kIGFyZSBkZWZpbmVkLlxyXG4gICAqIFRoaXMgbWVhbnMgcmVhY3Qgd2lsbCBjYWxsIHRoZSBvbGQgZm9ya1JlZiB3aXRoIGBudWxsYCBhbmQgdGhlIG5ldyBmb3JrUmVmXHJcbiAgICogd2l0aCB0aGUgcmVmLiBDbGVhbnVwIG5hdHVyYWxseSBlbWVyZ2VzIGZyb20gdGhpcyBiZWhhdmlvci5cclxuICAgKi9cbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWZBID09IG51bGwgJiYgcmVmQiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZlZhbHVlKSB7XG4gICAgICBzZXRSZWYocmVmQSwgcmVmVmFsdWUpO1xuICAgICAgc2V0UmVmKHJlZkIsIHJlZlZhbHVlKTtcbiAgICB9O1xuICB9LCBbcmVmQSwgcmVmQl0pO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUHJvcHMocHJvcHMpIHtcbiAgdmFyIHRpbWVvdXQgPSBwcm9wcy50aW1lb3V0LFxuICAgICAgX3Byb3BzJHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBzdHlsZSA9IF9wcm9wcyRzdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkc3R5bGUsXG4gICAgICBtb2RlID0gcHJvcHMubW9kZTtcbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogdHlwZW9mIHRpbWVvdXQgPT09ICdvYmplY3QnID8gdGltZW91dFttb2RlXSB8fCAwIDogdGltZW91dCxcbiAgICBlYXNpbmc6IHN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbixcbiAgICBkZWxheTogc3R5bGUudHJhbnNpdGlvbkRlbGF5XG4gIH07XG59XG5cbi8qKlxyXG4gKiBDcmVkaXQgdG8gTVVJIHRlYW0gQCBodHRwczovL211aS5jb21cclxuICovXG52YXIgZGVmYXVsdEVhc2luZyA9IHtcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gZWFzaW5nIGN1cnZlLlxuICBlYXNlSW5PdXQ6ICdjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpJyxcbiAgLy8gT2JqZWN0cyBlbnRlciB0aGUgc2NyZWVuIGF0IGZ1bGwgdmVsb2NpdHkgZnJvbSBvZmYtc2NyZWVuIGFuZFxuICAvLyBzbG93bHkgZGVjZWxlcmF0ZSB0byBhIHJlc3RpbmcgcG9pbnQuXG4gIGVhc2VPdXQ6ICdjdWJpYy1iZXppZXIoMC4wLCAwLCAwLjIsIDEpJyxcbiAgLy8gT2JqZWN0cyBsZWF2ZSB0aGUgc2NyZWVuIGF0IGZ1bGwgdmVsb2NpdHkuIFRoZXkgZG8gbm90IGRlY2VsZXJhdGUgd2hlbiBvZmYtc2NyZWVuLlxuICBlYXNlSW46ICdjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKScsXG4gIC8vIFRoZSBzaGFycCBjdXJ2ZSBpcyB1c2VkIGJ5IG9iamVjdHMgdGhhdCBtYXkgcmV0dXJuIHRvIHRoZSBzY3JlZW4gYXQgYW55IHRpbWUuXG4gIHNoYXJwOiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC42LCAxKSdcbn07XG4vKipcclxuICogQ1NTIGhhY2sgdG8gZm9yY2UgYSByZXBhaW50XHJcbiAqL1xuXG52YXIgcmVmbG93ID0gZnVuY3Rpb24gcmVmbG93KG5vZGUpIHtcbiAgLy8gV2UgaGF2ZSB0byBkbyBzb21ldGhpbmcgd2l0aCBub2RlLnNjcm9sbFRvcC5cbiAgLy8gT3RoZXJ3aXNlIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBjb21waWxlZCBjb2RlIGJ5IG9wdGltaXNlcnNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gIG5vZGUuc2Nyb2xsVG9wID0gbm9kZS5zY3JvbGxUb3A7XG59O1xuXG52YXIgZm9ybWF0TXMgPSBmdW5jdGlvbiBmb3JtYXRNcyhtaWxsaXNlY29uZHMpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobWlsbGlzZWNvbmRzKSArIFwibXNcIjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IFsnYWxsJ107XG4gIH1cblxuICB2YXIgX3JlZiA9IG9wdGlvbnMgfHwge30sXG4gICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgIGR1cmF0aW9uID0gX3JlZiRkdXJhdGlvbiA9PT0gdm9pZCAwID8gMzAwIDogX3JlZiRkdXJhdGlvbixcbiAgICAgIF9yZWYkZWFzaW5nID0gX3JlZi5lYXNpbmcsXG4gICAgICBlYXNpbmcgPSBfcmVmJGVhc2luZyA9PT0gdm9pZCAwID8gZGVmYXVsdEVhc2luZy5lYXNlSW5PdXQgOiBfcmVmJGVhc2luZyxcbiAgICAgIF9yZWYkZGVsYXkgPSBfcmVmLmRlbGF5LFxuICAgICAgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRkZWxheTtcblxuICB2YXIgcHJvcGVydGllcyA9IEFycmF5LmlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBbcHJvcHNdO1xuICByZXR1cm4gcHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKGFuaW1hdGVkUHJvcCkge1xuICAgIHZhciBmb3JtYXR0ZWREdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ3N0cmluZycgPyBkdXJhdGlvbiA6IGZvcm1hdE1zKGR1cmF0aW9uKTtcbiAgICB2YXIgZm9ybWF0dGVkRGVsYXkgPSB0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnID8gZGVsYXkgOiBmb3JtYXRNcyhkZWxheSk7XG4gICAgcmV0dXJuIGFuaW1hdGVkUHJvcCArIFwiIFwiICsgZm9ybWF0dGVkRHVyYXRpb24gKyBcIiBcIiArIGVhc2luZyArIFwiIFwiICsgZm9ybWF0dGVkRGVsYXk7XG4gIH0pLmpvaW4oJywnKTtcbn1cblxuZnVuY3Rpb24gb3duZXJEb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gb3duZXJXaW5kb3cobm9kZSkge1xuICB2YXIgZG9jID0gb3duZXJEb2N1bWVudChub2RlKTtcbiAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59XG4vKipcclxuICogQ29ycmVzcG9uZHMgdG8gMTAgZnJhbWVzIGF0IDYwIEh6LlxyXG4gKiBBIGZldyBieXRlcyBwYXlsb2FkIG92ZXJoZWFkIHdoZW4gbG9kYXNoL2RlYm91bmNlIGlzIH4zIGtCIGFuZCBkZWJvdW5jZSB+MzAwIEIuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgaWYgKHdhaXQgPT09IHZvaWQgMCkge1xuICAgIHdhaXQgPSAxNjY7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGZ1bmMuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICB9XG5cbiAgZGVib3VuY2VkLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSB0aGUgbm9kZSBzbyBpdCBjYW4ndCBiZSBzZWVuIG9uIHRoZSBzY3JlZW4uXHJcbiAqIExhdGVyLCB3ZSdyZSBnb2luZyB0byB0cmFuc2xhdGUgdGhlIG5vZGUgYmFjayB0byBpdHMgb3JpZ2luYWwgbG9jYXRpb24gd2l0aCBgbm9uZWAuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZVZhbHVlKGRpcmVjdGlvbiwgbm9kZSkge1xuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSBvd25lcldpbmRvdyhub2RlKTtcbiAgdmFyIHRyYW5zZm9ybTtcblxuICBpZiAobm9kZS5mYWtlVHJhbnNmb3JtKSB7XG4gICAgdHJhbnNmb3JtID0gbm9kZS5mYWtlVHJhbnNmb3JtO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb21wdXRlZFN0eWxlID0gY29udGFpbmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgdHJhbnNmb3JtID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctd2Via2l0LXRyYW5zZm9ybScpIHx8IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJyk7XG4gIH1cblxuICB2YXIgb2Zmc2V0WCA9IDA7XG4gIHZhciBvZmZzZXRZID0gMDtcblxuICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnICYmIHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHRyYW5zZm9ybVZhbHVlcyA9IHRyYW5zZm9ybS5zcGxpdCgnKCcpWzFdLnNwbGl0KCcpJylbMF0uc3BsaXQoJywnKTtcbiAgICBvZmZzZXRYID0gcGFyc2VJbnQodHJhbnNmb3JtVmFsdWVzWzRdLCAxMCk7XG4gICAgb2Zmc2V0WSA9IHBhcnNlSW50KHRyYW5zZm9ybVZhbHVlc1s1XSwgMTApO1xuICB9XG5cbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZVgoXCIgKyAoY29udGFpbmVyV2luZG93LmlubmVyV2lkdGggKyBvZmZzZXRYIC0gcmVjdC5sZWZ0KSArIFwicHgpXCI7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGVYKC1cIiArIChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC0gb2Zmc2V0WCkgKyBcInB4KVwiO1xuXG4gICAgY2FzZSAndXAnOlxuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlWShcIiArIChjb250YWluZXJXaW5kb3cuaW5uZXJIZWlnaHQgKyBvZmZzZXRZIC0gcmVjdC50b3ApICsgXCJweClcIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBkb3duXG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGVZKC1cIiArIChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC0gb2Zmc2V0WSkgKyBcInB4KVwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zbGF0ZVZhbHVlKGRpcmVjdGlvbiwgbm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgdmFyIHRyYW5zZm9ybSA9IGdldFRyYW5zbGF0ZVZhbHVlKGRpcmVjdGlvbiwgbm9kZSk7XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG59XG5cbnZhciBTbGlkZSA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgX3Byb3BzJGRpcmVjdGlvbiA9IHByb3BzLmRpcmVjdGlvbixcbiAgICAgIGRpcmVjdGlvbiA9IF9wcm9wcyRkaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdkb3duJyA6IF9wcm9wcyRkaXJlY3Rpb24sXG4gICAgICBpblByb3AgPSBwcm9wc1tcImluXCJdLFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIF9wcm9wcyR0aW1lb3V0ID0gcHJvcHMudGltZW91dCxcbiAgICAgIHRpbWVvdXQgPSBfcHJvcHMkdGltZW91dCA9PT0gdm9pZCAwID8gMCA6IF9wcm9wcyR0aW1lb3V0LFxuICAgICAgb25FbnRlciA9IHByb3BzLm9uRW50ZXIsXG4gICAgICBvbkVudGVyZWQgPSBwcm9wcy5vbkVudGVyZWQsXG4gICAgICBvbkV4aXQgPSBwcm9wcy5vbkV4aXQsXG4gICAgICBvbkV4aXRlZCA9IHByb3BzLm9uRXhpdGVkLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJkaXJlY3Rpb25cIiwgXCJpblwiLCBcInN0eWxlXCIsIFwidGltZW91dFwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRlZFwiXSk7XG5cbiAgdmFyIG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBoYW5kbGVSZWZJbnRlcm1lZGlhcnkgPSB1c2VGb3JrUmVmKGNoaWxkcmVuLnJlZiwgbm9kZVJlZik7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKGhhbmRsZVJlZkludGVybWVkaWFyeSwgcmVmKTtcblxuICB2YXIgaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcihub2RlLCBpc0FwcGVhcmluZykge1xuICAgIHNldFRyYW5zbGF0ZVZhbHVlKGRpcmVjdGlvbiwgbm9kZSk7XG4gICAgcmVmbG93KG5vZGUpO1xuXG4gICAgaWYgKG9uRW50ZXIpIHtcbiAgICAgIG9uRW50ZXIobm9kZSwgaXNBcHBlYXJpbmcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRW50ZXJpbmcgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcmluZyhub2RlKSB7XG4gICAgdmFyIGVhc2luZyA9IChzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKSB8fCBkZWZhdWx0RWFzaW5nLmVhc2VPdXQ7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wcyA9IGdldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgbW9kZTogJ2VudGVyJyxcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgc3R5bGUsIHtcbiAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBlYXNpbmdcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gY3JlYXRlVHJhbnNpdGlvbignLXdlYmtpdC10cmFuc2Zvcm0nLCB0cmFuc2l0aW9uUHJvcHMpO1xuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvbiA9IGNyZWF0ZVRyYW5zaXRpb24oJ3RyYW5zZm9ybScsIHRyYW5zaXRpb25Qcm9wcyk7XG4gICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUV4aXQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0KG5vZGUpIHtcbiAgICB2YXIgZWFzaW5nID0gKHN0eWxlID09PSBudWxsIHx8IHN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24pIHx8IGRlZmF1bHRFYXNpbmcuc2hhcnA7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wcyA9IGdldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgbW9kZTogJ2V4aXQnLFxuICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBzdHlsZSwge1xuICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSBjcmVhdGVUcmFuc2l0aW9uKCctd2Via2l0LXRyYW5zZm9ybScsIHRyYW5zaXRpb25Qcm9wcyk7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gY3JlYXRlVHJhbnNpdGlvbigndHJhbnNmb3JtJywgdHJhbnNpdGlvblByb3BzKTtcbiAgICBzZXRUcmFuc2xhdGVWYWx1ZShkaXJlY3Rpb24sIG5vZGUpO1xuXG4gICAgaWYgKG9uRXhpdCkge1xuICAgICAgb25FeGl0KG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gaGFuZGxlRXhpdGVkKG5vZGUpIHtcbiAgICAvLyBObyBuZWVkIGZvciB0cmFuc2l0aW9ucyB3aGVuIHRoZSBjb21wb25lbnQgaXMgaGlkZGVuXG4gICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG5cbiAgICBpZiAob25FeGl0ZWQpIHtcbiAgICAgIG9uRXhpdGVkKG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlUG9zaXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgc2V0VHJhbnNsYXRlVmFsdWUoZGlyZWN0aW9uLCBub2RlUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW2RpcmVjdGlvbl0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIFNraXAgY29uZmlndXJhdGlvbiB3aGVyZSB0aGUgcG9zaXRpb24gaXMgc2NyZWVuIHNpemUgaW52YXJpYW50LlxuICAgIGlmIChpblByb3AgfHwgZGlyZWN0aW9uID09PSAnZG93bicgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVSZXNpemUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNldFRyYW5zbGF0ZVZhbHVlKGRpcmVjdGlvbiwgbm9kZVJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgY29udGFpbmVyV2luZG93ID0gb3duZXJXaW5kb3cobm9kZVJlZi5jdXJyZW50KTtcbiAgICBjb250YWluZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlUmVzaXplLmNsZWFyKCk7XG4gICAgICBjb250YWluZXJXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICB9LCBbZGlyZWN0aW9uLCBpblByb3BdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWluUHJvcCkge1xuICAgICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkcmF3ZXIgd2hlbiB0aGUgZGlyZWN0aW9uIGNoYW5nZSBhbmRcbiAgICAgIC8vIHdoZW4gaXQncyBoaWRkZW4uXG4gICAgICB1cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfSwgW2luUHJvcCwgdXBkYXRlUG9zaXRpb25dKTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbiwgT2JqZWN0LmFzc2lnbih7XG4gICAgYXBwZWFyOiB0cnVlLFxuICAgIG5vZGVSZWY6IG5vZGVSZWYsXG4gICAgb25FbnRlcjogaGFuZGxlRW50ZXIsXG4gICAgb25FbnRlcmVkOiBvbkVudGVyZWQsXG4gICAgb25FbnRlcmluZzogaGFuZGxlRW50ZXJpbmcsXG4gICAgb25FeGl0OiBoYW5kbGVFeGl0LFxuICAgIG9uRXhpdGVkOiBoYW5kbGVFeGl0ZWQsXG4gICAgXCJpblwiOiBpblByb3AsXG4gICAgdGltZW91dDogdGltZW91dFxuICB9LCBvdGhlciksIGZ1bmN0aW9uIChzdGF0ZSwgY2hpbGRQcm9wcykge1xuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGRyZW4sIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaGFuZGxlUmVmLFxuICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgdmlzaWJpbGl0eTogc3RhdGUgPT09ICdleGl0ZWQnICYmICFpblByb3AgPyAnaGlkZGVuJyA6IHVuZGVmaW5lZFxuICAgICAgfSwgc3R5bGUsIHt9LCBjaGlsZHJlbi5wcm9wcy5zdHlsZSlcbiAgICB9LCBjaGlsZFByb3BzKSk7XG4gIH0pO1xufSk7XG5TbGlkZS5kaXNwbGF5TmFtZSA9ICdTbGlkZSc7XG5cbnZhciBTdmdJY29uID0gZnVuY3Rpb24gU3ZnSWNvbihwcm9wcykge1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBmb250U2l6ZTogMjAsXG4gICAgICBtYXJnaW5JbmxpbmVFbmQ6IDgsXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBmaWxsOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGZsZXhTaHJpbms6IDBcbiAgICB9XG4gIH0sIHByb3BzKSk7XG59O1xuXG52YXIgQ2hlY2tJY29uID0gZnVuY3Rpb24gQ2hlY2tJY29uKCkge1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdmdJY29uLCBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTIgMkM2LjUgMiAyIDYuNSAyIDEyUzYuNSAyMiAxMiAyMiAyMiAxNy41IDIyIDEyIDE3LjUgMiAxMiAyTTEwIDE3TDUgMTJMNi40MVxcbiAgICAgICAgMTAuNTlMMTAgMTQuMTdMMTcuNTkgNi41OEwxOSA4TDEwIDE3WlwiXG4gIH0pKTtcbn07XG5cbnZhciBXYXJuaW5nSWNvbiA9IGZ1bmN0aW9uIFdhcm5pbmdJY29uKCkge1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdmdJY29uLCBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTMsMTRIMTFWMTBIMTNNMTMsMThIMTFWMTZIMTNNMSwyMUgyM0wxMiwyTDEsMjFaXCJcbiAgfSkpO1xufTtcblxudmFyIEVycm9ySWNvbiA9IGZ1bmN0aW9uIEVycm9ySWNvbigpIHtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3ZnSWNvbiwgbnVsbCwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEyLDJDMTcuNTMsMiAyMiw2LjQ3IDIyLDEyQzIyLDE3LjUzIDE3LjUzLDIyIDEyLDIyQzYuNDcsMjIgMiwxNy41MyAyLDEyQzIsXFxuICAgICAgICA2LjQ3IDYuNDcsMiAxMiwyTTE1LjU5LDdMMTIsMTAuNTlMOC40MSw3TDcsOC40MUwxMC41OSwxMkw3LDE1LjU5TDguNDEsMTdMMTIsXFxuICAgICAgICAxMy40MUwxNS41OSwxN0wxNywxNS41OUwxMy40MSwxMkwxNyw4LjQxTDE1LjU5LDdaXCJcbiAgfSkpO1xufTtcblxudmFyIEluZm9JY29uID0gZnVuY3Rpb24gSW5mb0ljb24oKSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN2Z0ljb24sIG51bGwsIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMyw5SDExVjdIMTNNMTMsMTdIMTFWMTFIMTNNMTIsMkExMCwxMCAwIDAsMCAyLDEyQTEwLDEwIDAgMCwwIDEyLDIyQTEwLDEwIDAgMCxcXG4gICAgICAgIDAgMjIsMTJBMTAsMTAgMCAwLDAgMTIsMlpcIlxuICB9KSk7XG59O1xuXG52YXIgZGVmYXVsdEljb25WYXJpYW50cyA9IHtcbiAgXCJkZWZhdWx0XCI6IHVuZGVmaW5lZCxcbiAgc3VjY2VzczogLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tJY29uLCBudWxsKSxcbiAgd2FybmluZzogLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoV2FybmluZ0ljb24sIG51bGwpLFxuICBlcnJvcjogLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRXJyb3JJY29uLCBudWxsKSxcbiAgaW5mbzogLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW5mb0ljb24sIG51bGwpXG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIG1heFNuYWNrOiAzLFxuICBwZXJzaXN0OiBmYWxzZSxcbiAgaGlkZUljb25WYXJpYW50OiBmYWxzZSxcbiAgZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lcjogZmFsc2UsXG4gIHZhcmlhbnQ6ICdkZWZhdWx0JyxcbiAgYXV0b0hpZGVEdXJhdGlvbjogNTAwMCxcbiAgaWNvblZhcmlhbnQ6IGRlZmF1bHRJY29uVmFyaWFudHMsXG4gIGFuY2hvck9yaWdpbjoge1xuICAgIHZlcnRpY2FsOiAnYm90dG9tJyxcbiAgICBob3Jpem9udGFsOiAnbGVmdCdcbiAgfSxcbiAgVHJhbnNpdGlvbkNvbXBvbmVudDogU2xpZGUsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjoge1xuICAgIGVudGVyOiAyMjUsXG4gICAgZXhpdDogMTk1XG4gIH1cbn07XG4vKipcclxuICogRGVyaXZlcyB0aGUgcmlnaHQgYXV0b0hpZGVEdXJhdGlvbiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBmb2xsb3dpbmdcclxuICogcHJvcml0eSBvcmRlcjogMTogT3B0aW9ucywgMjogUHJvcHMsIDM6IGRlZmF1bHQgZmFsbGJhY2tcclxuICovXG5cbnZhciBnZXRBdXRvSGlkZUR1cmF0aW9uID0gZnVuY3Rpb24gZ2V0QXV0b0hpZGVEdXJhdGlvbihvcHRpb25zRHVyYXRpb24sIHByb3BzRHVyYXRpb24pIHtcbiAgdmFyIGlzTnVtYmVyT3JOdWxsID0gZnVuY3Rpb24gaXNOdW1iZXJPck51bGwobnVtYmVyaXNoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBudW1iZXJpc2ggPT09ICdudW1iZXInIHx8IG51bWJlcmlzaCA9PT0gbnVsbDtcbiAgfTtcblxuICBpZiAoaXNOdW1iZXJPck51bGwob3B0aW9uc0R1cmF0aW9uKSkgcmV0dXJuIG9wdGlvbnNEdXJhdGlvbjtcbiAgaWYgKGlzTnVtYmVyT3JOdWxsKHByb3BzRHVyYXRpb24pKSByZXR1cm4gcHJvcHNEdXJhdGlvbjtcbiAgcmV0dXJuIGRlZmF1bHRzLmF1dG9IaWRlRHVyYXRpb247XG59O1xuLyoqXHJcbiAqIERlcml2ZXMgdGhlIHJpZ2h0IHRyYW5zaXRpb25EdXJhdGlvbiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBmb2xsb3dpbmdcclxuICogcHJvcml0eSBvcmRlcjogMTogT3B0aW9ucywgMjogUHJvcHMsIDM6IGRlZmF1bHQgZmFsbGJhY2tcclxuICovXG5cblxudmFyIGdldFRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25EdXJhdGlvbihvcHRpb25zRHVyYXRpb24sIHByb3BzRHVyYXRpb24pIHtcbiAgdmFyIGlzID0gZnVuY3Rpb24gaXMoaXRlbSwgdHlwZXMpIHtcbiAgICByZXR1cm4gdHlwZXMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBpdGVtID09PSB0O1xuICAgIH0pO1xuICB9O1xuXG4gIGlmIChpcyhvcHRpb25zRHVyYXRpb24sIFsnc3RyaW5nJywgJ251bWJlciddKSkge1xuICAgIHJldHVybiBvcHRpb25zRHVyYXRpb247XG4gIH1cblxuICBpZiAoaXMob3B0aW9uc0R1cmF0aW9uLCBbJ29iamVjdCddKSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMudHJhbnNpdGlvbkR1cmF0aW9uLCB7fSwgaXMocHJvcHNEdXJhdGlvbiwgWydvYmplY3QnXSkgJiYgcHJvcHNEdXJhdGlvbiwge30sIG9wdGlvbnNEdXJhdGlvbik7XG4gIH1cblxuICBpZiAoaXMocHJvcHNEdXJhdGlvbiwgWydzdHJpbmcnLCAnbnVtYmVyJ10pKSB7XG4gICAgcmV0dXJuIHByb3BzRHVyYXRpb247XG4gIH1cblxuICBpZiAoaXMocHJvcHNEdXJhdGlvbiwgWydvYmplY3QnXSkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRzLnRyYW5zaXRpb25EdXJhdGlvbiwge30sIHByb3BzRHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRzLnRyYW5zaXRpb25EdXJhdGlvbjtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKG9wdGlvbnMsIHByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZSwgc2hvdWxkT2JqZWN0TWVyZ2UpIHtcbiAgICBpZiAoc2hvdWxkT2JqZWN0TWVyZ2UgPT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkT2JqZWN0TWVyZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkT2JqZWN0TWVyZ2UpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdHNbbmFtZV0sIHt9LCBwcm9wc1tuYW1lXSwge30sIG9wdGlvbnNbbmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnYXV0b0hpZGVEdXJhdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRBdXRvSGlkZUR1cmF0aW9uKG9wdGlvbnMuYXV0b0hpZGVEdXJhdGlvbiwgcHJvcHMuYXV0b0hpZGVEdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICd0cmFuc2l0aW9uRHVyYXRpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uKG9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uLCBwcm9wcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zW25hbWVdIHx8IHByb3BzW25hbWVdIHx8IGRlZmF1bHRzW25hbWVdO1xuICB9O1xufTtcblxuZnVuY3Rpb24gbWFrZVN0eWxlcyhzdHlsZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHN0eWxlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJba2V5XSA9IGNzcyh2YWx1ZSksIF9leHRlbmRzMikpO1xuICB9LCB7fSk7XG59XG52YXIgQ29tcG9uZW50Q2xhc3NlcyA9IHtcbiAgU25hY2tiYXJDb250YWluZXI6ICdub3Rpc3RhY2stU25hY2tiYXJDb250YWluZXInLFxuICBTbmFja2JhcjogJ25vdGlzdGFjay1TbmFja2JhcicsXG4gIENvbGxhcHNlV3JhcHBlcjogJ25vdGlzdGFjay1Db2xsYXBzZVdyYXBwZXInLFxuICBNdWlDb250ZW50OiAnbm90aXN0YWNrLU11aUNvbnRlbnQnLFxuICBNdWlDb250ZW50VmFyaWFudDogZnVuY3Rpb24gTXVpQ29udGVudFZhcmlhbnQodmFyaWFudCkge1xuICAgIHJldHVybiBcIm5vdGlzdGFjay1NdWlDb250ZW50LVwiICsgdmFyaWFudDtcbiAgfVxufTtcblxudmFyIGNsYXNzZXMgPSAvKiNfX1BVUkVfXyovbWFrZVN0eWxlcyh7XG4gIHJvb3Q6IHtcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgZW50ZXJlZDoge1xuICAgIGhlaWdodDogJ2F1dG8nXG4gIH1cbn0pO1xudmFyIGNvbGxhcHNlZFNpemUgPSAnMHB4JztcbnZhciB0aW1lb3V0ID0gMTc1O1xudmFyIENvbGxhcHNlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBpblByb3AgPSBwcm9wc1tcImluXCJdLFxuICAgICAgb25FeGl0ZWQgPSBwcm9wcy5vbkV4aXRlZDtcbiAgdmFyIHdyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihyZWYsIG5vZGVSZWYpO1xuXG4gIHZhciBnZXRXcmFwcGVyU2l6ZSA9IGZ1bmN0aW9uIGdldFdyYXBwZXJTaXplKCkge1xuICAgIHJldHVybiB3cmFwcGVyUmVmLmN1cnJlbnQgPyB3cmFwcGVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0IDogMDtcbiAgfTtcblxuICB2YXIgaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcihub2RlKSB7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBjb2xsYXBzZWRTaXplO1xuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlcmluZyA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyaW5nKG5vZGUpIHtcbiAgICB2YXIgd3JhcHBlclNpemUgPSBnZXRXcmFwcGVyU2l6ZSgpO1xuXG4gICAgdmFyIF9nZXRUcmFuc2l0aW9uUHJvcHMgPSBnZXRUcmFuc2l0aW9uUHJvcHMoe1xuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIG1vZGU6ICdlbnRlcidcbiAgICB9KSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2dldFRyYW5zaXRpb25Qcm9wcy5kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nID0gX2dldFRyYW5zaXRpb25Qcm9wcy5lYXNpbmc7XG5cbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHR5cGVvZiB0cmFuc2l0aW9uRHVyYXRpb24gPT09ICdzdHJpbmcnID8gdHJhbnNpdGlvbkR1cmF0aW9uIDogdHJhbnNpdGlvbkR1cmF0aW9uICsgXCJtc1wiO1xuICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gd3JhcHBlclNpemUgKyBcInB4XCI7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBlYXNpbmcgfHwgJyc7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUVudGVyZWQgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcmVkKG5vZGUpIHtcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgfTtcblxuICB2YXIgaGFuZGxlRXhpdCA9IGZ1bmN0aW9uIGhhbmRsZUV4aXQobm9kZSkge1xuICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gZ2V0V3JhcHBlclNpemUoKSArIFwicHhcIjtcbiAgfTtcblxuICB2YXIgaGFuZGxlRXhpdGluZyA9IGZ1bmN0aW9uIGhhbmRsZUV4aXRpbmcobm9kZSkge1xuICAgIHJlZmxvdyhub2RlKTtcblxuICAgIHZhciBfZ2V0VHJhbnNpdGlvblByb3BzMiA9IGdldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgbW9kZTogJ2V4aXQnXG4gICAgfSksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9nZXRUcmFuc2l0aW9uUHJvcHMyLmR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcgPSBfZ2V0VHJhbnNpdGlvblByb3BzMi5lYXNpbmc7XG5cbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHR5cGVvZiB0cmFuc2l0aW9uRHVyYXRpb24gPT09ICdzdHJpbmcnID8gdHJhbnNpdGlvbkR1cmF0aW9uIDogdHJhbnNpdGlvbkR1cmF0aW9uICsgXCJtc1wiO1xuICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gY29sbGFwc2VkU2l6ZTtcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IGVhc2luZyB8fCAnJztcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uLCB7XG4gICAgXCJpblwiOiBpblByb3AsXG4gICAgdW5tb3VudE9uRXhpdDogdHJ1ZSxcbiAgICBvbkVudGVyOiBoYW5kbGVFbnRlcixcbiAgICBvbkVudGVyZWQ6IGhhbmRsZUVudGVyZWQsXG4gICAgb25FbnRlcmluZzogaGFuZGxlRW50ZXJpbmcsXG4gICAgb25FeGl0OiBoYW5kbGVFeGl0LFxuICAgIG9uRXhpdGVkOiBvbkV4aXRlZCxcbiAgICBvbkV4aXRpbmc6IGhhbmRsZUV4aXRpbmcsXG4gICAgbm9kZVJlZjogbm9kZVJlZixcbiAgICB0aW1lb3V0OiB0aW1lb3V0XG4gIH0sIGZ1bmN0aW9uIChzdGF0ZSwgY2hpbGRQcm9wcykge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgcmVmOiBoYW5kbGVSZWYsXG4gICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBzdGF0ZSA9PT0gJ2VudGVyZWQnICYmIGNsYXNzZXMuZW50ZXJlZCksXG4gICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBtaW5IZWlnaHQ6IGNvbGxhcHNlZFNpemUsXG4gICAgICAgIHRyYW5zaXRpb246IGNyZWF0ZVRyYW5zaXRpb24oJ2hlaWdodCcpXG4gICAgICB9LCBzdGF0ZSA9PT0gJ2VudGVyZWQnICYmIHtcbiAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuICAgICAgfSwge30sIHN0YXRlID09PSAnZXhpdGVkJyAmJiAhaW5Qcm9wICYmIHtcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgICAgIH0pXG4gICAgfSwgY2hpbGRQcm9wcyksIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgcmVmOiB3cmFwcGVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBDb21wb25lbnRDbGFzc2VzLkNvbGxhcHNlV3JhcHBlcixcbiAgICAgIC8vIEhhY2sgdG8gZ2V0IGNoaWxkcmVuIHdpdGggYSBuZWdhdGl2ZSBtYXJnaW4gdG8gbm90IGZhbHNpZnkgdGhlIGhlaWdodCBjb21wdXRhdGlvbi5cbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgfVxuICAgIH0sIGNoaWxkcmVuKSk7XG4gIH0pO1xufSk7XG5Db2xsYXBzZS5kaXNwbGF5TmFtZSA9ICdDb2xsYXBzZSc7XG5cbnZhciBkaXJlY3Rpb24gPSB7XG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIGJvdHRvbTogJ3VwJyxcbiAgdG9wOiAnZG93bidcbn07XG52YXIgZ2V0U2xpZGVEaXJlY3Rpb24gPSBmdW5jdGlvbiBnZXRTbGlkZURpcmVjdGlvbihhbmNob3JPcmlnaW4pIHtcbiAgaWYgKGFuY2hvck9yaWdpbi5ob3Jpem9udGFsICE9PSAnY2VudGVyJykge1xuICAgIHJldHVybiBkaXJlY3Rpb25bYW5jaG9yT3JpZ2luLmhvcml6b250YWxdO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvblthbmNob3JPcmlnaW4udmVydGljYWxdO1xufTtcbi8qKiBUcmFuZm9ybXMgY2xhc3NlcyBuYW1lICovXG5cbnZhciB0b1NuYWNrYmFyQW5jaG9yT3JpZ2luID0gZnVuY3Rpb24gdG9TbmFja2JhckFuY2hvck9yaWdpbihhbmNob3JPcmlnaW4pIHtcbiAgcmV0dXJuIFwiYW5jaG9yT3JpZ2luXCIgKyBvcmlnaW5LZXlFeHRyYWN0b3IoYW5jaG9yT3JpZ2luKTtcbn07XG4vKipcclxuICogT21pdCBTbmFja2JhckNvbnRhaW5lciBjbGFzcyBrZXlzIHRoYXQgYXJlIG5vdCBuZWVkZWQgZm9yIFNuYWNrYmFySXRlbVxyXG4gKi9cblxudmFyIGtlZXBTbmFja2JhckNsYXNzS2V5cyA9IGZ1bmN0aW9uIGtlZXBTbmFja2JhckNsYXNzS2V5cyhjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0ge307XG4gIH1cblxuICB2YXIgY29udGFpbmVyQ2xhc3NlcyA9IHtcbiAgICBjb250YWluZXJSb290OiB0cnVlLFxuICAgIGNvbnRhaW5lckFuY2hvck9yaWdpblRvcENlbnRlcjogdHJ1ZSxcbiAgICBjb250YWluZXJBbmNob3JPcmlnaW5Cb3R0b21DZW50ZXI6IHRydWUsXG4gICAgY29udGFpbmVyQW5jaG9yT3JpZ2luVG9wUmlnaHQ6IHRydWUsXG4gICAgY29udGFpbmVyQW5jaG9yT3JpZ2luQm90dG9tUmlnaHQ6IHRydWUsXG4gICAgY29udGFpbmVyQW5jaG9yT3JpZ2luVG9wTGVmdDogdHJ1ZSxcbiAgICBjb250YWluZXJBbmNob3JPcmlnaW5Cb3R0b21MZWZ0OiB0cnVlXG4gIH07XG4gIHJldHVybiBPYmplY3Qua2V5cyhjbGFzc2VzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhY29udGFpbmVyQ2xhc3Nlc1trZXldO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgdmFyIF9leHRlbmRzMjtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgb2JqLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltrZXldID0gY2xhc3Nlc1trZXldLCBfZXh0ZW5kczIpKTtcbiAgfSwge30pO1xufTtcblxudmFyIG5vT3AkMSA9IGZ1bmN0aW9uIG5vT3AoKSB7XG4gIC8qICovXG59O1xuLyoqXHJcbiAqIENyZWRpdCB0byBNVUkgdGVhbSBAIGh0dHBzOi8vbXVpLmNvbVxyXG4gKiBTYWZlIGNoYWluZWQgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFdpbGwgb25seSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gaWYgbmVlZGVkLFxyXG4gKiBvdGhlcndpc2Ugd2lsbCBwYXNzIGJhY2sgZXhpc3RpbmcgZnVuY3Rpb25zIG9yIG51bGwuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihmdW5jcywgc25hY2tiYXJJZCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZnVuYykge1xuICAgIGlmIChmdW5jID09PSBudWxsIHx8IGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmd1bXMgPSBbXS5jb25jYXQoYXJncyk7XG5cbiAgICAgIGlmIChzbmFja2JhcklkICYmIGFyZ3Vtcy5pbmRleE9mKHNuYWNrYmFySWQpID09PSAtMSkge1xuICAgICAgICBhcmd1bXMucHVzaChzbmFja2JhcklkKTtcbiAgICAgIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgICAgIGFjYy5hcHBseSh0aGlzLCBhcmd1bXMpO1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bXMpO1xuICAgIH07XG4gIH0sIG5vT3AkMSk7XG59XG5cbi8qKlxyXG4gKiBDcmVkaXQgdG8gTVVJIHRlYW0gQCBodHRwczovL211aS5jb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDA5OSNpc3N1ZWNvbW1lbnQtNDQwMDEzODkyXHJcbiAqL1xudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VFdmVudENhbGxiYWNrKGZuKSB7XG4gIHZhciByZWYgPSB1c2VSZWYoZm4pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBmbjtcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgvLyBAdHMtZXhwZWN0LWVycm9yIGhpZGUgYHRoaXNgXG4gICAgICAocmVmLmN1cnJlbnQpLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKVxuICAgICk7XG4gIH0sIFtdKTtcbn1cblxuLyoqXHJcbiAqIENyZWRpdCB0byBNVUkgdGVhbSBAIGh0dHBzOi8vbXVpLmNvbVxyXG4gKi9cbnZhciBTbmFja2JhciA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgYXV0b0hpZGVEdXJhdGlvbiA9IHByb3BzLmF1dG9IaWRlRHVyYXRpb24sXG4gICAgICBfcHJvcHMkZGlzYWJsZVdpbmRvd0IgPSBwcm9wcy5kaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyLFxuICAgICAgZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lciA9IF9wcm9wcyRkaXNhYmxlV2luZG93QiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVdpbmRvd0IsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIF9wcm9wcyRTbmFja2JhclByb3BzID0gcHJvcHMuU25hY2tiYXJQcm9wcyxcbiAgICAgIFNuYWNrYmFyUHJvcHMgPSBfcHJvcHMkU25hY2tiYXJQcm9wcyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkU25hY2tiYXJQcm9wcztcbiAgdmFyIHRpbWVyQXV0b0hpZGUgPSB1c2VSZWYoKTtcbiAgdmFyIGhhbmRsZUNsb3NlID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgIG9uQ2xvc2UuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBzZXRBdXRvSGlkZVRpbWVyID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoYXV0b0hpZGVEdXJhdGlvblBhcmFtKSB7XG4gICAgaWYgKCFvbkNsb3NlIHx8IGF1dG9IaWRlRHVyYXRpb25QYXJhbSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRpbWVyQXV0b0hpZGUuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyQXV0b0hpZGUuY3VycmVudCk7XG4gICAgfVxuXG4gICAgdGltZXJBdXRvSGlkZS5jdXJyZW50ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVDbG9zZShudWxsLCAndGltZW91dCcsIGlkKTtcbiAgICB9LCBhdXRvSGlkZUR1cmF0aW9uUGFyYW0pO1xuICB9KTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0QXV0b0hpZGVUaW1lcihhdXRvSGlkZUR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRpbWVyQXV0b0hpZGUuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJBdXRvSGlkZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbb3BlbiwgYXV0b0hpZGVEdXJhdGlvbiwgc2V0QXV0b0hpZGVUaW1lcl0pO1xuICAvKipcclxuICAgKiBQYXVzZSB0aGUgdGltZXIgd2hlbiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIHRoZSBTbmFja2JhclxyXG4gICAqIG9yIHdoZW4gdGhlIHVzZXIgaGlkZSB0aGUgd2luZG93LlxyXG4gICAqL1xuXG4gIHZhciBoYW5kbGVQYXVzZSA9IGZ1bmN0aW9uIGhhbmRsZVBhdXNlKCkge1xuICAgIGlmICh0aW1lckF1dG9IaWRlLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lckF1dG9IaWRlLmN1cnJlbnQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmVzdGFydCB0aGUgdGltZXIgd2hlbiB0aGUgdXNlciBpcyBubyBsb25nZXIgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgU25hY2tiYXJcclxuICAgKiBvciB3aGVuIHRoZSB3aW5kb3cgaXMgc2hvd24gYmFjay5cclxuICAgKi9cblxuXG4gIHZhciBoYW5kbGVSZXN1bWUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGF1dG9IaWRlRHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgc2V0QXV0b0hpZGVUaW1lcihhdXRvSGlkZUR1cmF0aW9uICogMC41KTtcbiAgICB9XG4gIH0sIFthdXRvSGlkZUR1cmF0aW9uLCBzZXRBdXRvSGlkZVRpbWVyXSk7XG5cbiAgdmFyIGhhbmRsZU1vdXNlRW50ZXIgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKGV2ZW50KSB7XG4gICAgaWYgKFNuYWNrYmFyUHJvcHMub25Nb3VzZUVudGVyKSB7XG4gICAgICBTbmFja2JhclByb3BzLm9uTW91c2VFbnRlcihldmVudCk7XG4gICAgfVxuXG4gICAgaGFuZGxlUGF1c2UoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlTW91c2VMZWF2ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICBpZiAoU25hY2tiYXJQcm9wcy5vbk1vdXNlTGVhdmUpIHtcbiAgICAgIFNuYWNrYmFyUHJvcHMub25Nb3VzZUxlYXZlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBoYW5kbGVSZXN1bWUoKTtcbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lciAmJiBvcGVuKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVSZXN1bWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVQYXVzZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVSZXN1bWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZVBhdXNlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2Rpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXIsIGhhbmRsZVJlc3VtZSwgb3Blbl0pO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICByZWY6IHJlZlxuICB9LCBTbmFja2JhclByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KENvbXBvbmVudENsYXNzZXMuU25hY2tiYXIsIGNsYXNzTmFtZSksXG4gICAgb25Nb3VzZUVudGVyOiBoYW5kbGVNb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZTogaGFuZGxlTW91c2VMZWF2ZVxuICB9KSwgY2hpbGRyZW4pO1xufSk7XG5TbmFja2Jhci5kaXNwbGF5TmFtZSA9ICdTbmFja2Jhcic7XG5cbnZhciBfcm9vdDtcbnZhciBjbGFzc2VzJDEgPSAvKiNfX1BVUkVfXyovbWFrZVN0eWxlcyh7XG4gIHJvb3Q6IChfcm9vdCA9IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICBmbGV4R3JvdzogMVxuICB9LCBfcm9vdFticmVha3BvaW50cy51cFNtXSA9IHtcbiAgICBmbGV4R3JvdzogJ2luaXRpYWwnLFxuICAgIG1pbldpZHRoOiAnMjg4cHgnXG4gIH0sIF9yb290KVxufSk7XG52YXIgU25hY2tiYXJDb250ZW50ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF9yZWYsIHJlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgcmVmOiByZWYsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMkMS5yb290LCBjbGFzc05hbWUpXG4gIH0sIHByb3BzKSk7XG59KTtcblNuYWNrYmFyQ29udGVudC5kaXNwbGF5TmFtZSA9ICdTbmFja2JhckNvbnRlbnQnO1xuXG52YXIgY2xhc3NlcyQyID0gLyojX19QVVJFX18qL21ha2VTdHlsZXMoe1xuICByb290OiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnIzMxMzEzMScsXG4gICAgZm9udFNpemU6ICcwLjg3NXJlbScsXG4gICAgbGluZUhlaWdodDogMS40MyxcbiAgICBsZXR0ZXJTcGFjaW5nOiAnMC4wMTA3MWVtJyxcbiAgICBjb2xvcjogJyNmZmYnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIHBhZGRpbmc6ICc2cHggMTZweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICBib3hTaGFkb3c6ICcwcHggM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsMC4yKSwwcHggNnB4IDEwcHggMHB4IHJnYmEoMCwwLDAsMC4xNCksMHB4IDFweCAxOHB4IDBweCByZ2JhKDAsMCwwLDAuMTIpJ1xuICB9LFxuICBsZXNzUGFkZGluZzoge1xuICAgIHBhZGRpbmdMZWZ0OiA4ICogMi41ICsgXCJweFwiXG4gIH0sXG4gIFwiZGVmYXVsdFwiOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnIzMxMzEzMSdcbiAgfSxcbiAgc3VjY2Vzczoge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyM0M2EwNDcnXG4gIH0sXG4gIGVycm9yOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2QzMmYyZidcbiAgfSxcbiAgd2FybmluZzoge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyNmZjk4MDAnXG4gIH0sXG4gIGluZm86IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjE5NmYzJ1xuICB9LFxuICBtZXNzYWdlOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIHBhZGRpbmc6ICc4cHggMCdcbiAgfSxcbiAgYWN0aW9uOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICBwYWRkaW5nTGVmdDogJzE2cHgnLFxuICAgIG1hcmdpblJpZ2h0OiAnLThweCdcbiAgfVxufSk7XG52YXIgYXJpYURlc2NyaWJlZGJ5ID0gJ25vdGlzdGFjay1zbmFja2Jhcic7XG52YXIgTWF0ZXJpYWxEZXNpZ25Db250ZW50ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIGlkID0gcHJvcHMuaWQsXG4gICAgICBtZXNzYWdlID0gcHJvcHMubWVzc2FnZSxcbiAgICAgIGNvbXBvbmVudE9yRnVuY3Rpb25BY3Rpb24gPSBwcm9wcy5hY3Rpb24sXG4gICAgICBpY29uVmFyaWFudCA9IHByb3BzLmljb25WYXJpYW50LFxuICAgICAgdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICBoaWRlSWNvblZhcmlhbnQgPSBwcm9wcy5oaWRlSWNvblZhcmlhbnQsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICB2YXIgaWNvbiA9IGljb25WYXJpYW50W3ZhcmlhbnRdO1xuICB2YXIgYWN0aW9uID0gY29tcG9uZW50T3JGdW5jdGlvbkFjdGlvbjtcblxuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGlvbiA9IGFjdGlvbihpZCk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTbmFja2JhckNvbnRlbnQsIHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICByb2xlOiBcImFsZXJ0XCIsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRieSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbHN4KENvbXBvbmVudENsYXNzZXMuTXVpQ29udGVudCwgQ29tcG9uZW50Q2xhc3Nlcy5NdWlDb250ZW50VmFyaWFudCh2YXJpYW50KSwgY2xhc3NlcyQyLnJvb3QsIGNsYXNzZXMkMlt2YXJpYW50XSwgY2xhc3NOYW1lLCAhaGlkZUljb25WYXJpYW50ICYmIGljb24gJiYgY2xhc3NlcyQyLmxlc3NQYWRkaW5nKVxuICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogYXJpYURlc2NyaWJlZGJ5LFxuICAgIGNsYXNzTmFtZTogY2xhc3NlcyQyLm1lc3NhZ2VcbiAgfSwgIWhpZGVJY29uVmFyaWFudCA/IGljb24gOiBudWxsLCBtZXNzYWdlKSwgYWN0aW9uICYmIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyQyLmFjdGlvblxuICB9LCBhY3Rpb24pKTtcbn0pO1xuTWF0ZXJpYWxEZXNpZ25Db250ZW50LmRpc3BsYXlOYW1lID0gJ01hdGVyaWFsRGVzaWduQ29udGVudCc7XG52YXIgTWF0ZXJpYWxEZXNpZ25Db250ZW50JDEgPSAvKiNfX1BVUkVfXyovbWVtbyhNYXRlcmlhbERlc2lnbkNvbnRlbnQpO1xuXG52YXIgc3R5bGVzID0gLyojX19QVVJFX18qL21ha2VTdHlsZXMoe1xuICB3cmFwcGVkUm9vdDoge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScsXG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIG1pbldpZHRoOiAnMjg4cHgnXG4gIH1cbn0pO1xuXG52YXIgU25hY2tiYXJJdGVtID0gZnVuY3Rpb24gU25hY2tiYXJJdGVtKHByb3BzKSB7XG4gIHZhciB0aW1lb3V0ID0gdXNlUmVmKCk7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHRydWUpLFxuICAgICAgY29sbGFwc2VkID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0Q29sbGFwc2VkID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciBoYW5kbGVDbG9zZSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihbcHJvcHMuc25hY2sub25DbG9zZSwgcHJvcHMub25DbG9zZV0pO1xuXG4gIHZhciBoYW5kbGVFbnRlcmVkID0gZnVuY3Rpb24gaGFuZGxlRW50ZXJlZCgpIHtcbiAgICBpZiAocHJvcHMuc25hY2sucmVxdWVzdENsb3NlKSB7XG4gICAgICBoYW5kbGVDbG9zZShudWxsLCAnaW5zdHJ1Y3RlZCcsIHByb3BzLnNuYWNrLmlkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUV4aXRlZFNjcmVlbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0aW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldENvbGxhcHNlZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIHJldHVybiAhY29sO1xuICAgICAgfSk7XG4gICAgfSwgMTI1KTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGltZW91dC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHNuYWNrID0gcHJvcHMuc25hY2ssXG4gICAgICBhbGxDbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRDb21wb25lbnQgPSBwcm9wcy5Db21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkQ29tcG9uZW50ID09PSB2b2lkIDAgPyBNYXRlcmlhbERlc2lnbkNvbnRlbnQkMSA6IF9wcm9wcyRDb21wb25lbnQ7XG4gIHZhciBjbGFzc2VzID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGtlZXBTbmFja2JhckNsYXNzS2V5cyhhbGxDbGFzc2VzKTtcbiAgfSwgW2FsbENsYXNzZXNdKTtcblxuICB2YXIgb3BlbiA9IHNuYWNrLm9wZW4sXG4gICAgICBTbmFja2JhclByb3BzID0gc25hY2suU25hY2tiYXJQcm9wcyxcbiAgICAgIFRyYW5zaXRpb25Db21wb25lbnQgPSBzbmFjay5UcmFuc2l0aW9uQ29tcG9uZW50LFxuICAgICAgVHJhbnNpdGlvblByb3BzID0gc25hY2suVHJhbnNpdGlvblByb3BzLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gc25hY2sudHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lciA9IHNuYWNrLmRpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXIsXG4gICAgICBjb21wb25lbnRPckZ1bmN0aW9uQ29udGVudCA9IHNuYWNrLmNvbnRlbnQsXG4gICAgICBvdGhlclNuYWNrID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc25hY2ssIFtcIm9wZW5cIiwgXCJTbmFja2JhclByb3BzXCIsIFwiVHJhbnNpdGlvbkNvbXBvbmVudFwiLCBcIlRyYW5zaXRpb25Qcm9wc1wiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcImRpc2FibGVXaW5kb3dCbHVyTGlzdGVuZXJcIiwgXCJjb250ZW50XCIsIFwiZW50ZXJlZFwiLCBcInJlcXVlc3RDbG9zZVwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRlZFwiXSk7XG5cbiAgdmFyIHRyYW5zaXRpb25Qcm9wcyA9IF9leHRlbmRzKHtcbiAgICBkaXJlY3Rpb246IGdldFNsaWRlRGlyZWN0aW9uKG90aGVyU25hY2suYW5jaG9yT3JpZ2luKSxcbiAgICB0aW1lb3V0OiB0cmFuc2l0aW9uRHVyYXRpb25cbiAgfSwgVHJhbnNpdGlvblByb3BzKTtcblxuICB2YXIgY29udGVudCA9IGNvbXBvbmVudE9yRnVuY3Rpb25Db250ZW50O1xuXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50KG90aGVyU25hY2suaWQsIG90aGVyU25hY2subWVzc2FnZSk7XG4gIH1cblxuICB2YXIgY2FsbGJhY2tzID0gWydvbkVudGVyJywgJ29uRW50ZXJlZCcsICdvbkV4aXQnLCAnb25FeGl0ZWQnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2JOYW1lKSB7XG4gICAgdmFyIF9leHRlbmRzMjtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltjYk5hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKFtwcm9wcy5zbmFja1tjYk5hbWVdLCBwcm9wc1tjYk5hbWVdXSwgb3RoZXJTbmFjay5pZCksIF9leHRlbmRzMikpO1xuICB9LCB7fSk7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbGxhcHNlLCB7XG4gICAgXCJpblwiOiBjb2xsYXBzZWQsXG4gICAgb25FeGl0ZWQ6IGNhbGxiYWNrcy5vbkV4aXRlZFxuICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNuYWNrYmFyLCB7XG4gICAgb3Blbjogb3BlbixcbiAgICBpZDogb3RoZXJTbmFjay5pZCxcbiAgICBkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyOiBkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyLFxuICAgIGF1dG9IaWRlRHVyYXRpb246IG90aGVyU25hY2suYXV0b0hpZGVEdXJhdGlvbixcbiAgICBjbGFzc05hbWU6IGNsc3goc3R5bGVzLndyYXBwZWRSb290LCBjbGFzc2VzLnJvb3QsIGNsYXNzZXNbdG9TbmFja2JhckFuY2hvck9yaWdpbihvdGhlclNuYWNrLmFuY2hvck9yaWdpbildKSxcbiAgICBTbmFja2JhclByb3BzOiBTbmFja2JhclByb3BzLFxuICAgIG9uQ2xvc2U6IGhhbmRsZUNsb3NlXG4gIH0sIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkNvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNpdGlvblByb3BzLCB7XG4gICAgYXBwZWFyOiB0cnVlLFxuICAgIFwiaW5cIjogb3BlbixcbiAgICBvbkV4aXQ6IGNhbGxiYWNrcy5vbkV4aXQsXG4gICAgb25FeGl0ZWQ6IGhhbmRsZUV4aXRlZFNjcmVlbixcbiAgICBvbkVudGVyOiBjYWxsYmFja3Mub25FbnRlcixcbiAgICAvLyBvcmRlciBtYXR0ZXJzLiBmaXJzdCBjYWxsYmFja3Mub25FbnRlcmVkIHRvIHNldCBlbnRlcmVkOiB0cnVlLFxuICAgIC8vIHRoZW4gaGFuZGxlRW50ZXJlZCB0byBjaGVjayBpZiB0aGVyZSdzIGEgcmVxdWVzdCBmb3IgY2xvc2luZ1xuICAgIG9uRW50ZXJlZDogY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKFtjYWxsYmFja3Mub25FbnRlcmVkLCBoYW5kbGVFbnRlcmVkXSwgb3RoZXJTbmFjay5pZClcbiAgfSksIGNvbnRlbnQgfHwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIG90aGVyU25hY2spKSkpKTtcbn07XG5cbnZhciBfcm9vdCQxLCBfcm9vdERlbnNlLCBfbGVmdCwgX3JpZ2h0LCBfY2VudGVyO1xudmFyIGluZGVudHMgPSB7XG4gIHZpZXc6IHtcbiAgICBcImRlZmF1bHRcIjogMjAsXG4gICAgZGVuc2U6IDRcbiAgfSxcbiAgc25hY2tiYXI6IHtcbiAgICBcImRlZmF1bHRcIjogNixcbiAgICBkZW5zZTogMlxuICB9XG59O1xudmFyIGNvbGxhcHNlV3JhcHBlciA9IFwiLlwiICsgQ29tcG9uZW50Q2xhc3Nlcy5Db2xsYXBzZVdyYXBwZXI7XG52YXIgeHNXaWR0aE1hcmdpbiA9IDE2O1xudmFyIHN0eWxlcyQxID0gLyojX19QVVJFX18qL21ha2VTdHlsZXMoe1xuICByb290OiAoX3Jvb3QkMSA9IHtcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgbWF4SGVpZ2h0OiAnMTAwJScsXG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgekluZGV4OiAxNDAwLFxuICAgIGhlaWdodDogJ2F1dG8nLFxuICAgIHdpZHRoOiAnYXV0bycsXG4gICAgdHJhbnNpdGlvbjogLyojX19QVVJFX18qL2NyZWF0ZVRyYW5zaXRpb24oWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnbWF4LXdpZHRoJ10sIHtcbiAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICBlYXNpbmc6ICdlYXNlJ1xuICAgIH0pLFxuICAgIC8vIGNvbnRhaW5lciBpdHNlbGYgaXMgaW52aXNpYmxlIGFuZCBzaG91bGQgbm90IGJsb2NrIGNsaWNrcywgY2xpY2tzIHNob3VsZCBiZSBwYXNzZWQgdG8gaXRzIGNoaWxkcmVuXG4gICAgLy8gYSBwb2ludGVyRXZlbnRzOiBhbGwgaXMgYXBwbGllZCBpbiB0aGUgY29sbGFwc2UgY29tcG9uZW50XG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gIH0sIF9yb290JDFbY29sbGFwc2VXcmFwcGVyXSA9IHtcbiAgICBwYWRkaW5nOiBpbmRlbnRzLnNuYWNrYmFyW1wiZGVmYXVsdFwiXSArIFwicHggMHB4XCIsXG4gICAgdHJhbnNpdGlvbjogJ3BhZGRpbmcgMzAwbXMgZWFzZSAwbXMnXG4gIH0sIF9yb290JDEubWF4V2lkdGggPSBcImNhbGMoMTAwJSAtIFwiICsgaW5kZW50cy52aWV3W1wiZGVmYXVsdFwiXSAqIDIgKyBcInB4KVwiLCBfcm9vdCQxW2JyZWFrcG9pbnRzLmRvd25Yc10gPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBtYXhXaWR0aDogXCJjYWxjKDEwMCUgLSBcIiArIHhzV2lkdGhNYXJnaW4gKiAyICsgXCJweClcIlxuICB9LCBfcm9vdCQxKSxcbiAgcm9vdERlbnNlOiAoX3Jvb3REZW5zZSA9IHt9LCBfcm9vdERlbnNlW2NvbGxhcHNlV3JhcHBlcl0gPSB7XG4gICAgcGFkZGluZzogaW5kZW50cy5zbmFja2Jhci5kZW5zZSArIFwicHggMHB4XCJcbiAgfSwgX3Jvb3REZW5zZSksXG4gIHRvcDoge1xuICAgIHRvcDogaW5kZW50cy52aWV3W1wiZGVmYXVsdFwiXSAtIGluZGVudHMuc25hY2tiYXJbXCJkZWZhdWx0XCJdICsgXCJweFwiLFxuICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nXG4gIH0sXG4gIGJvdHRvbToge1xuICAgIGJvdHRvbTogaW5kZW50cy52aWV3W1wiZGVmYXVsdFwiXSAtIGluZGVudHMuc25hY2tiYXJbXCJkZWZhdWx0XCJdICsgXCJweFwiLFxuICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4tcmV2ZXJzZSdcbiAgfSxcbiAgbGVmdDogKF9sZWZ0ID0ge1xuICAgIGxlZnQ6IGluZGVudHMudmlld1tcImRlZmF1bHRcIl0gKyBcInB4XCJcbiAgfSwgX2xlZnRbYnJlYWtwb2ludHMudXBTbV0gPSB7XG4gICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnXG4gIH0sIF9sZWZ0W2JyZWFrcG9pbnRzLmRvd25Yc10gPSB7XG4gICAgbGVmdDogeHNXaWR0aE1hcmdpbiArIFwicHhcIlxuICB9LCBfbGVmdCksXG4gIHJpZ2h0OiAoX3JpZ2h0ID0ge1xuICAgIHJpZ2h0OiBpbmRlbnRzLnZpZXdbXCJkZWZhdWx0XCJdICsgXCJweFwiXG4gIH0sIF9yaWdodFticmVha3BvaW50cy51cFNtXSA9IHtcbiAgICBhbGlnbkl0ZW1zOiAnZmxleC1lbmQnXG4gIH0sIF9yaWdodFticmVha3BvaW50cy5kb3duWHNdID0ge1xuICAgIHJpZ2h0OiB4c1dpZHRoTWFyZ2luICsgXCJweFwiXG4gIH0sIF9yaWdodCksXG4gIGNlbnRlcjogKF9jZW50ZXIgPSB7XG4gICAgbGVmdDogJzUwJScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSdcbiAgfSwgX2NlbnRlclticmVha3BvaW50cy51cFNtXSA9IHtcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xuICB9LCBfY2VudGVyKVxufSk7XG5cbnZhciBTbmFja2JhckNvbnRhaW5lciA9IGZ1bmN0aW9uIFNuYWNrYmFyQ29udGFpbmVyKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc2VzID0gX3Byb3BzJGNsYXNzZXMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJGNsYXNzZXMsXG4gICAgICBhbmNob3JPcmlnaW4gPSBwcm9wcy5hbmNob3JPcmlnaW4sXG4gICAgICBkZW5zZSA9IHByb3BzLmRlbnNlLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGNvbWJpbmVkQ2xhc3NuYW1lID0gY2xzeChDb21wb25lbnRDbGFzc2VzLlNuYWNrYmFyQ29udGFpbmVyLCBzdHlsZXMkMVthbmNob3JPcmlnaW4udmVydGljYWxdLCBzdHlsZXMkMVthbmNob3JPcmlnaW4uaG9yaXpvbnRhbF0sIHN0eWxlcyQxLnJvb3QsIC8vIHJvb3Qgc2hvdWxkIGNvbWUgYWZ0ZXIgb3RoZXJzIHRvIG92ZXJyaWRlIG1heFdpZHRoXG4gIGNsYXNzZXMuY29udGFpbmVyUm9vdCwgY2xhc3Nlc1tcImNvbnRhaW5lckFuY2hvck9yaWdpblwiICsgb3JpZ2luS2V5RXh0cmFjdG9yKGFuY2hvck9yaWdpbildLCBkZW5zZSAmJiBzdHlsZXMkMS5yb290RGVuc2UpO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjb21iaW5lZENsYXNzbmFtZVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG52YXIgU25hY2tiYXJDb250YWluZXIkMSA9IC8qI19fUFVSRV9fKi9tZW1vKFNuYWNrYmFyQ29udGFpbmVyKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfX0RFVl9fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxudmFyIG1lc3NhZ2VzID0ge1xuICBOT19QRVJTSVNUX0FMTDogXCJSZWFjaGVkIG1heFNuYWNrIHdoaWxlIGFsbCBlbnF1ZXVlZCBzbmFja2JhcnMgaGF2ZSAncGVyc2lzdCcgZmxhZy4gTm90aXN0YWNrIHdpbGwgZGlzbWlzcyB0aGUgb2xkZXN0IHNuYWNrYmFyIGFueXdheSB0byBhbGxvdyBvdGhlciBvbmVzIGluIHRoZSBxdWV1ZSB0byBiZSBwcmVzZW50ZWQuXCJcbn07XG52YXIgd2FybmluZyA9IChmdW5jdGlvbiAobWVzc2FnZUtleSkge1xuICBpZiAoIV9fREVWX18pIHJldHVybjtcbiAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlS2V5XTtcblxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihcIldBUk5JTkcgLSBub3Rpc3RhY2s6IFwiICsgbWVzc2FnZSk7XG4gIH1cblxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoeCkge31cbn0pO1xuXG52YXIgaXNPcHRpb25zID0gZnVuY3Rpb24gaXNPcHRpb25zKG1lc3NhZ2VPck9wdGlvbnMpIHtcbiAgdmFyIGlzTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlT3JPcHRpb25zID09PSAnc3RyaW5nJyB8fCBpc1ZhbGlkRWxlbWVudChtZXNzYWdlT3JPcHRpb25zKTtcbiAgcmV0dXJuICFpc01lc3NhZ2U7XG59O1xuXG52YXIgZW5xdWV1ZVNuYWNrYmFyO1xudmFyIGNsb3NlU25hY2tiYXI7XG5cbnZhciBTbmFja2JhclByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFNuYWNrYmFyUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNuYWNrYmFyUHJvdmlkZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgc25hY2tiYXIgdG8gdGhlIHF1ZXVlIHRvIGJlIHByZXNlbnRlZC5cclxuICAgICAqIFJldHVybnMgZ2VuZXJhdGVkIG9yIHVzZXIgZGVmaW5lZCBrZXkgcmVmZXJlbmNpbmcgdGhlIG5ldyBzbmFja2JhciBvciBudWxsXHJcbiAgICAgKi9cblxuICAgIF90aGlzLmVucXVldWVTbmFja2JhciA9IGZ1bmN0aW9uIChtZXNzYWdlT3JPcHRpb25zLCBvcHRzT3JVbmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRzT3JVbmRlZmluZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRzT3JVbmRlZmluZWQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lc3NhZ2VPck9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlT3JPcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5xdWV1ZVNuYWNrYmFyIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdHMgPSBpc09wdGlvbnMobWVzc2FnZU9yT3B0aW9ucykgPyBtZXNzYWdlT3JPcHRpb25zIDogb3B0c09yVW5kZWZpbmVkO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBpc09wdGlvbnMobWVzc2FnZU9yT3B0aW9ucykgPyBtZXNzYWdlT3JPcHRpb25zLm1lc3NhZ2UgOiBtZXNzYWdlT3JPcHRpb25zO1xuXG4gICAgICB2YXIga2V5ID0gb3B0cy5rZXksXG4gICAgICAgICAgcHJldmVudER1cGxpY2F0ZSA9IG9wdHMucHJldmVudER1cGxpY2F0ZSxcbiAgICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uob3B0cywgW1wia2V5XCIsIFwicHJldmVudER1cGxpY2F0ZVwiXSk7XG5cbiAgICAgIHZhciBoYXNTcGVjaWZpZWRLZXkgPSBpc0RlZmluZWQoa2V5KTtcbiAgICAgIHZhciBpZCA9IGhhc1NwZWNpZmllZEtleSA/IGtleSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgTWF0aC5yYW5kb20oKTtcbiAgICAgIHZhciBtZXJnZXIgPSBtZXJnZShvcHRpb25zLCBfdGhpcy5wcm9wcyk7XG5cbiAgICAgIHZhciBzbmFjayA9IF9leHRlbmRzKHtcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9LCBvcHRpb25zLCB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgIGVudGVyZWQ6IGZhbHNlLFxuICAgICAgICByZXF1ZXN0Q2xvc2U6IGZhbHNlLFxuICAgICAgICBwZXJzaXN0OiBtZXJnZXIoJ3BlcnNpc3QnKSxcbiAgICAgICAgYWN0aW9uOiBtZXJnZXIoJ2FjdGlvbicpLFxuICAgICAgICBjb250ZW50OiBtZXJnZXIoJ2NvbnRlbnQnKSxcbiAgICAgICAgdmFyaWFudDogbWVyZ2VyKCd2YXJpYW50JyksXG4gICAgICAgIGFuY2hvck9yaWdpbjogbWVyZ2VyKCdhbmNob3JPcmlnaW4nKSxcbiAgICAgICAgZGlzYWJsZVdpbmRvd0JsdXJMaXN0ZW5lcjogbWVyZ2VyKCdkaXNhYmxlV2luZG93Qmx1ckxpc3RlbmVyJyksXG4gICAgICAgIGF1dG9IaWRlRHVyYXRpb246IG1lcmdlcignYXV0b0hpZGVEdXJhdGlvbicpLFxuICAgICAgICBoaWRlSWNvblZhcmlhbnQ6IG1lcmdlcignaGlkZUljb25WYXJpYW50JyksXG4gICAgICAgIFRyYW5zaXRpb25Db21wb25lbnQ6IG1lcmdlcignVHJhbnNpdGlvbkNvbXBvbmVudCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IG1lcmdlcigndHJhbnNpdGlvbkR1cmF0aW9uJyksXG4gICAgICAgIFRyYW5zaXRpb25Qcm9wczogbWVyZ2VyKCdUcmFuc2l0aW9uUHJvcHMnLCB0cnVlKSxcbiAgICAgICAgaWNvblZhcmlhbnQ6IG1lcmdlcignaWNvblZhcmlhbnQnLCB0cnVlKSxcbiAgICAgICAgc3R5bGU6IG1lcmdlcignc3R5bGUnLCB0cnVlKSxcbiAgICAgICAgU25hY2tiYXJQcm9wczogbWVyZ2VyKCdTbmFja2JhclByb3BzJywgdHJ1ZSksXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChfdGhpcy5wcm9wcy5jbGFzc05hbWUsIG9wdGlvbnMuY2xhc3NOYW1lKVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzbmFjay5wZXJzaXN0KSB7XG4gICAgICAgIHNuYWNrLmF1dG9IaWRlRHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAocHJldmVudER1cGxpY2F0ZSA9PT0gdW5kZWZpbmVkICYmIF90aGlzLnByb3BzLnByZXZlbnREdXBsaWNhdGUgfHwgcHJldmVudER1cGxpY2F0ZSkge1xuICAgICAgICAgIHZhciBjb21wYXJlRnVuY3Rpb24gPSBmdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1NwZWNpZmllZEtleSA/IGl0ZW0uaWQgPT09IGlkIDogaXRlbS5tZXNzYWdlID09PSBtZXNzYWdlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgaW5RdWV1ZSA9IHN0YXRlLnF1ZXVlLmZpbmRJbmRleChjb21wYXJlRnVuY3Rpb24pID4gLTE7XG4gICAgICAgICAgdmFyIGluVmlldyA9IHN0YXRlLnNuYWNrcy5maW5kSW5kZXgoY29tcGFyZUZ1bmN0aW9uKSA+IC0xO1xuXG4gICAgICAgICAgaWYgKGluUXVldWUgfHwgaW5WaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURpc3BsYXlTbmFjayhfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBxdWV1ZTogW10uY29uY2F0KHN0YXRlLnF1ZXVlLCBbc25hY2tdKVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2VyOiBEaXNwbGF5IHNuYWNrIGlmIHRoZXJlJ3Mgc3BhY2UgZm9yIGl0LiBPdGhlcndpc2UsIGltbWVkaWF0ZWx5XHJcbiAgICAgKiBiZWdpbiBkaXNtaXNzaW5nIHRoZSBvbGRlc3QgbWVzc2FnZSB0byBzdGFydCBzaG93aW5nIHRoZSBuZXcgb25lLlxyXG4gICAgICovXG5cblxuICAgIF90aGlzLmhhbmRsZURpc3BsYXlTbmFjayA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIHNuYWNrcyA9IHN0YXRlLnNuYWNrcztcblxuICAgICAgaWYgKHNuYWNrcy5sZW5ndGggPj0gX3RoaXMubWF4U25hY2spIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURpc21pc3NPbGRlc3Qoc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMucHJvY2Vzc1F1ZXVlKHN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogUmVkdWNlcjogRGlzcGxheSBpdGVtcyAobm90aWZpY2F0aW9ucykgaW4gdGhlIHF1ZXVlIGlmIHRoZXJlJ3Mgc3BhY2UgZm9yIHRoZW0uXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMucHJvY2Vzc1F1ZXVlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICB2YXIgcXVldWUgPSBzdGF0ZS5xdWV1ZSxcbiAgICAgICAgICBzbmFja3MgPSBzdGF0ZS5zbmFja3M7XG5cbiAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzbmFja3M6IFtdLmNvbmNhdChzbmFja3MsIFtxdWV1ZVswXV0pLFxuICAgICAgICAgIHF1ZXVlOiBxdWV1ZS5zbGljZSgxLCBxdWV1ZS5sZW5ndGgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFJlZHVjZXI6IEhpZGUgb2xkZXN0IHNuYWNrYmFyIG9uIHRoZSBzY3JlZW4gYmVjYXVzZSB0aGVyZSBleGlzdHMgYSBuZXcgb25lIHdoaWNoIHdlIGhhdmUgdG8gZGlzcGxheS5cclxuICAgICAqIChpZ25vcmluZyB0aGUgb25lIHdpdGggJ3BlcnNpc3QnIGZsYWcuIGkuZS4gZXhwbGljaXRseSB0b2xkIGJ5IHVzZXIgbm90IHRvIGdldCBkaXNtaXNzZWQpLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgMTogSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG1lc3NhZ2UgbGVhdmluZyB0aGUgc2NyZWVuLCBubyBuZXcgbWVzc2FnZXMgYXJlIGRpc21pc3NlZC5cclxuICAgICAqIE5vdGUgMjogSWYgdGhlIG9sZGVzdCBtZXNzYWdlIGhhcyBub3QgeWV0IGVudGVyZWQgdGhlIHNjcmVlbiwgb25seSBhIHJlcXVlc3QgdG8gY2xvc2UgdGhlXHJcbiAgICAgKiAgICAgICAgIHNuYWNrYmFyIGlzIG1hZGUuIE9uY2UgaXQgZW50ZXJlZCB0aGUgc2NyZWVuLCBpdCB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc21pc3NlZC5cclxuICAgICAqL1xuXG5cbiAgICBfdGhpcy5oYW5kbGVEaXNtaXNzT2xkZXN0ID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuc25hY2tzLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFpdGVtLm9wZW4gfHwgaXRlbS5yZXF1ZXN0Q2xvc2U7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3BwZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpZ25vcmUgPSBmYWxzZTtcbiAgICAgIHZhciBwZXJzaXN0ZW50Q291bnQgPSBzdGF0ZS5zbmFja3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIChjdXJyZW50Lm9wZW4gJiYgY3VycmVudC5wZXJzaXN0ID8gMSA6IDApO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIGlmIChwZXJzaXN0ZW50Q291bnQgPT09IF90aGlzLm1heFNuYWNrKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ05PX1BFUlNJU1RfQUxMJykgOiB2b2lkIDA7XG4gICAgICAgIGlnbm9yZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbmFja3MgPSBzdGF0ZS5zbmFja3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghcG9wcGVkICYmICghaXRlbS5wZXJzaXN0IHx8IGlnbm9yZSkpIHtcbiAgICAgICAgICBwb3BwZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFpdGVtLmVudGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaXRlbSwge1xuICAgICAgICAgICAgICByZXF1ZXN0Q2xvc2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdGVtLm9uQ2xvc2UpIHtcbiAgICAgICAgICAgIGl0ZW0ub25DbG9zZShudWxsLCAnbWF4c25hY2snLCBpdGVtLmlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25DbG9zZSkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DbG9zZShudWxsLCAnbWF4c25hY2snLCBpdGVtLmlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGl0ZW0sIHtcbiAgICAgICAgICAgIG9wZW46IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNuYWNrczogc25hY2tzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBlbnRlcmVkIHN0YXRlIG9mIHRoZSBzbmFja2JhciB3aXRoIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMuaGFuZGxlRW50ZXJlZFNuYWNrID0gZnVuY3Rpb24gKG5vZGUsIGlzQXBwZWFyaW5nLCBrZXkpIHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVFbnRlcmVkU25hY2sgQ2Fubm90IGJlIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHNuYWNrcyA9IF9yZWYuc25hY2tzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNuYWNrczogc25hY2tzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IGtleSA/IF9leHRlbmRzKHt9LCBpdGVtLCB7XG4gICAgICAgICAgICAgIGVudGVyZWQ6IHRydWVcbiAgICAgICAgICAgIH0pIDogX2V4dGVuZHMoe30sIGl0ZW0pO1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogSGlkZSBhIHNuYWNrYmFyIGFmdGVyIGl0cyB0aW1lb3V0LlxyXG4gICAgICovXG5cblxuICAgIF90aGlzLmhhbmRsZUNsb3NlU25hY2sgPSBmdW5jdGlvbiAoZXZlbnQsIHJlYXNvbiwga2V5KSB7XG4gICAgICAvLyBzaG91bGQgbm90IHVzZSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24gZm9yIG9uQ2xvc2UuXG4gICAgICAvLyBiZWNhdXNlIHRoaXMuY2xvc2VTbmFja2JhciBjYWxsZWQgdGhpcyBmdW5jdGlvblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xvc2UpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25DbG9zZShldmVudCwgcmVhc29uLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvdWxkQ2xvc2VBbGwgPSBrZXkgPT09IHVuZGVmaW5lZDtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBzbmFja3MgPSBfcmVmMi5zbmFja3MsXG4gICAgICAgICAgICBxdWV1ZSA9IF9yZWYyLnF1ZXVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNuYWNrczogc25hY2tzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKCFzaG91bGRDbG9zZUFsbCAmJiBpdGVtLmlkICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZW50ZXJlZCA/IF9leHRlbmRzKHt9LCBpdGVtLCB7XG4gICAgICAgICAgICAgIG9wZW46IGZhbHNlXG4gICAgICAgICAgICB9KSA6IF9leHRlbmRzKHt9LCBpdGVtLCB7XG4gICAgICAgICAgICAgIHJlcXVlc3RDbG9zZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcXVldWU6IHF1ZXVlLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgIT09IGtleTtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIENsb3NlIHNuYWNrYmFyIHdpdGggdGhlIGdpdmVuIGtleVxyXG4gICAgICovXG5cblxuICAgIF90aGlzLmNsb3NlU25hY2tiYXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvLyBjYWxsIGluZGl2aWR1YWwgc25hY2tiYXIgb25DbG9zZSBjYWxsYmFjayBwYXNzZWQgdGhyb3VnaCBvcHRpb25zIHBhcmFtZXRlclxuICAgICAgdmFyIHRvQmVDbG9zZWQgPSBfdGhpcy5zdGF0ZS5zbmFja3MuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0RlZmluZWQoa2V5KSAmJiB0b0JlQ2xvc2VkICYmIHRvQmVDbG9zZWQub25DbG9zZSkge1xuICAgICAgICB0b0JlQ2xvc2VkLm9uQ2xvc2UobnVsbCwgJ2luc3RydWN0ZWQnLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5oYW5kbGVDbG9zZVNuYWNrKG51bGwsICdpbnN0cnVjdGVkJywga2V5KTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogV2hlbiB3ZSBzZXQgb3BlbiBhdHRyaWJ1dGUgb2YgYSBzbmFja2JhciB0byBmYWxzZSAoaS5lLiBhZnRlciB3ZSBoaWRlIGEgc25hY2tiYXIpLFxyXG4gICAgICogaXQgbGVhdmVzIHRoZSBzY3JlZW4gYW5kIGltbWVkaWF0ZWx5IGFmdGVyIGxlYXZpbmcgYW5pbWF0aW9uIGlzIGRvbmUsIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBnZXRzIGNhbGxlZC4gV2UgcmVtb3ZlIHRoZSBoaWRkZW4gc25hY2tiYXIgZnJvbSBzdGF0ZSBhbmQgdGhlbiBkaXNwbGF5IG5vdGlmaWNhdGlvbnNcclxuICAgICAqIHdhaXRpbmcgaW4gdGhlIHF1ZXVlIChpZiBhbnkpLiBJZiBhZnRlciB0aGlzIHByb2Nlc3MgdGhlIHF1ZXVlIGlzIG5vdCBlbXB0eSwgdGhlXHJcbiAgICAgKiBvbGRlc3QgbWVzc2FnZSBpcyBkaXNtaXNzZWQuXHJcbiAgICAgKi9cblxuXG4gICAgX3RoaXMuaGFuZGxlRXhpdGVkU25hY2sgPSBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICBpZiAoIWlzRGVmaW5lZChrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlRXhpdGVkU25hY2sgQ2Fubm90IGJlIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IF90aGlzLnByb2Nlc3NRdWV1ZShfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzbmFja3M6IHN0YXRlLnNuYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkICE9PSBrZXk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChuZXdTdGF0ZS5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRGlzbWlzc09sZGVzdChuZXdTdGF0ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZW5xdWV1ZVNuYWNrYmFyID0gX3RoaXMuZW5xdWV1ZVNuYWNrYmFyO1xuICAgIGNsb3NlU25hY2tiYXIgPSBfdGhpcy5jbG9zZVNuYWNrYmFyO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc25hY2tzOiBbXSxcbiAgICAgIHF1ZXVlOiBbXSxcbiAgICAgIGNvbnRleHRWYWx1ZToge1xuICAgICAgICBlbnF1ZXVlU25hY2tiYXI6IF90aGlzLmVucXVldWVTbmFja2Jhci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgY2xvc2VTbmFja2JhcjogX3RoaXMuY2xvc2VTbmFja2Jhci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNuYWNrYmFyUHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgY29udGV4dFZhbHVlID0gdGhpcy5zdGF0ZS5jb250ZXh0VmFsdWU7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZG9tUm9vdCA9IF90aGlzJHByb3BzLmRvbVJvb3QsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIF90aGlzJHByb3BzJGRlbnNlID0gX3RoaXMkcHJvcHMuZGVuc2UsXG4gICAgICAgIGRlbnNlID0gX3RoaXMkcHJvcHMkZGVuc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3RoaXMkcHJvcHMkZGVuc2UsXG4gICAgICAgIF90aGlzJHByb3BzJENvbXBvbmVudCA9IF90aGlzJHByb3BzLkNvbXBvbmVudHMsXG4gICAgICAgIENvbXBvbmVudHMgPSBfdGhpcyRwcm9wcyRDb21wb25lbnQgPT09IHZvaWQgMCA/IHt9IDogX3RoaXMkcHJvcHMkQ29tcG9uZW50LFxuICAgICAgICBjbGFzc2VzID0gX3RoaXMkcHJvcHMuY2xhc3NlcztcbiAgICB2YXIgY2F0ZWcgPSB0aGlzLnN0YXRlLnNuYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycmVudCkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIGNhdGVnb3J5ID0gb3JpZ2luS2V5RXh0cmFjdG9yKGN1cnJlbnQuYW5jaG9yT3JpZ2luKTtcbiAgICAgIHZhciBleGlzdGluZ09mQ2F0ZWdvcnkgPSBhY2NbY2F0ZWdvcnldIHx8IFtdO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY2MsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW2NhdGVnb3J5XSA9IFtdLmNvbmNhdChleGlzdGluZ09mQ2F0ZWdvcnksIFtjdXJyZW50XSksIF9leHRlbmRzMikpO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgc25hY2tiYXJzID0gT2JqZWN0LmtleXMoY2F0ZWcpLm1hcChmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICB2YXIgc25hY2tzID0gY2F0ZWdbb3JpZ2luXTtcbiAgICAgIHZhciBub21pbmVlU25hY2sgPSBzbmFja3NbMF07XG4gICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTbmFja2JhckNvbnRhaW5lciQxLCB7XG4gICAgICAgIGtleTogb3JpZ2luLFxuICAgICAgICBkZW5zZTogZGVuc2UsXG4gICAgICAgIGFuY2hvck9yaWdpbjogbm9taW5lZVNuYWNrLmFuY2hvck9yaWdpbixcbiAgICAgICAgY2xhc3NlczogY2xhc3Nlc1xuICAgICAgfSwgc25hY2tzLm1hcChmdW5jdGlvbiAoc25hY2spIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU25hY2tiYXJJdGVtLCB7XG4gICAgICAgICAga2V5OiBzbmFjay5pZCxcbiAgICAgICAgICBzbmFjazogc25hY2ssXG4gICAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudHNbc25hY2sudmFyaWFudF0sXG4gICAgICAgICAgb25DbG9zZTogX3RoaXMyLmhhbmRsZUNsb3NlU25hY2ssXG4gICAgICAgICAgb25FbnRlcjogX3RoaXMyLnByb3BzLm9uRW50ZXIsXG4gICAgICAgICAgb25FeGl0OiBfdGhpczIucHJvcHMub25FeGl0LFxuICAgICAgICAgIG9uRXhpdGVkOiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oW190aGlzMi5oYW5kbGVFeGl0ZWRTbmFjaywgX3RoaXMyLnByb3BzLm9uRXhpdGVkXSwgc25hY2suaWQpLFxuICAgICAgICAgIG9uRW50ZXJlZDogY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKFtfdGhpczIuaGFuZGxlRW50ZXJlZFNuYWNrLCBfdGhpczIucHJvcHMub25FbnRlcmVkXSwgc25hY2suaWQpXG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNuYWNrYmFyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICAgIH0sIGNoaWxkcmVuLCBkb21Sb290ID8gY3JlYXRlUG9ydGFsKHNuYWNrYmFycywgZG9tUm9vdCkgOiBzbmFja2JhcnMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTbmFja2JhclByb3ZpZGVyLCBbe1xuICAgIGtleTogXCJtYXhTbmFja1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMubWF4U25hY2sgfHwgZGVmYXVsdHMubWF4U25hY2s7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNuYWNrYmFyUHJvdmlkZXI7XG59KENvbXBvbmVudCk7XG5cbnZhciB1c2VTbmFja2JhciA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFNuYWNrYmFyQ29udGV4dCk7XG59KTtcblxuZXhwb3J0IHsgTWF0ZXJpYWxEZXNpZ25Db250ZW50JDEgYXMgTWF0ZXJpYWxEZXNpZ25Db250ZW50LCBTbmFja2JhckNvbnRlbnQsIFNuYWNrYmFyUHJvdmlkZXIsIFRyYW5zaXRpb24sIGNsb3NlU25hY2tiYXIsIGVucXVldWVTbmFja2JhciwgdXNlU25hY2tiYXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlzdGFjay5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/notistack/notistack.esm.js\n");

/***/ })

};
;